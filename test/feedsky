<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet href='http://feed.feedsky.com/styles/temp01.xsl' type='text/xsl' ?><!--这是一个由Feedsy提供技术支持的Feed，为了提高读者阅读的体验，以及满足用户美化自己Feed的需要，我们设计了多种精美的Feed模板，提供给大家选择，所有最终呈现出来的样式，皆由用户自愿选择使用，未经许可，任何团体和个人，请不要擅自修改样式或者盗用，这是对于用户选择权的尊重。--><rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:fs="http://www.feedsky.com/namespace/feed" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><atom:link href="http://feed.feedsky.com/programmer" type="application/rss+xml" rel="self"></atom:link><fs:self_link href="http://feed.feedsky.com/programmer" type="application/rss+xml"></fs:self_link><lastBuildDate>Wed, 20 Mar 2013 13:53:32 GMT</lastBuildDate><title>《程序员》杂志官网</title><description>技术改变世界 创新驱动中国</description><image><url>http://www.feedsky.com/feed/programmer/sc/gif</url><title>《程序员》杂志官网</title><link>http://www.programmer.com.cn</link></image><link>http://www.programmer.com.cn</link><sy:updatePeriod>hourly</sy:updatePeriod><sy:updateFrequency>1</sy:updateFrequency><language>en</language><pubDate>Wed, 20 Mar 2013 14:15:01 GMT</pubDate><item><title>努力成为优秀的工程师</title><link>http://www.programmer.com.cn/15606/</link><content:encoded>&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;文/李航&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;&lt;strong&gt;华为诺亚方舟实验室首席科学家李航结合自己的亲身经验，提出了成为优秀工程师应该遵循的五项原则：面对问题，解决问题；系统地解决问题；站在用户角度看问题；以最小的代价获得最大的效益；磨在细处。&lt;/strong&gt;&lt;/span&gt;&lt;span id=&quot;more-15606&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;我一直在IT企业的研究部门任职，迄今经历了三家公司：NEC、微软、华为。工作都是既有基础研究，又有产品开发。其实，这两者既有密切联系，性质上又迥然不同。前者在于发现或发明普适性的理论与方法，后者在于开发实用性的系统与工具。可以说，前者需要的思维方式、基本技能与素质是科学家的，而后者是工程师的。我经常提醒自己，一定要明确在具体项目中自己到底带着什么“帽子”在工作，是科学家，还是工程师？&lt;/p&gt;
&lt;p&gt;我曾经将如何成为优秀科学家的体会整理成若干篇博文发表，而本文来谈谈如何成为优秀工程师的一些心得。我认为，做工程时应该遵循五项原则，并在实际的工作中把它们作为行为 指南。这些原则是：面对问题、解决问题，系统地解决问题，站在用户角度看问题，以最小的代价获得最大的效益，磨在细处。在这里做一总结，仅供大家参考。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;面对问题，解决问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;西方有句谚语：“当手中拿着榔头的时候，你会觉得看到的东西都像是钉子”。根据自己的喜好、特长、习惯来解决问题是工程师的大忌。做工程时最重要的是要面对问题、解决问题。可取的策略应该是探明问题的本质，弄清问题的机理，用最直接、最有效的办法解决问题。经验告诉我们，拐弯抹角地解决问题，效果总是不好的。做工程时并不一定需要理论。只要能够有效地解决问题，其实什么方法都行。“不管白猫黑猫，捉住老鼠就是好猫”在这里也是适用的。当然有理论指导的方法 往往更能抓住问题的本质，以其为工具常常能把问题解决得更好。&lt;/p&gt;
&lt;p&gt;在NEC工作时，我曾参加一个自然语言研究小组的立项会议。他们建议开发语音 系统来帮助用户遥控电视机，因为现在的遥控器操作都过于复杂，不利于老人与儿童使用。用语音声控电视，当然是很好的想法，现在仍有许多企业在进行这项应用 的开发。印象特别深的是他们断言，除了通过语音的办法，不存在其他解决方案。当时，我也认为他们的想法很有道理。&lt;/p&gt;
&lt;p&gt;不料，没过几个月，日本的其他几家电器公司推出了用编码遥控电视的方法，更简单、更实用。遥控器的操作主要靠数字输入，每个电视节目都配上一个编码，报纸每天将编码在电视节目栏中公布，用户只要输入编码即可观看或录制相应的节目。&lt;/p&gt;
&lt;p&gt;这件事对我的内心产生了很大的震动，自问为什么NEC的同事们只想到自然语言这条路，而忽视了其他路？不正是因为他们手里拿着自然语言这个榔头的缘故吗？&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;系统地解决问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;动画片《没头脑与不高兴》描写了两位少年：“没头脑”与“不高兴”。“没头脑”做起事来总是丢三落四，“不高兴”待人处事总爱别别扭扭。不久，“没头脑”当上了工程师，“不高兴”当上了演员。“没头脑”设计了一座一百九十九层高的少年宫，楼建好以后，才发现忘记了设计电梯。孩子们为了在这个大楼顶层的剧院看 戏，需要带着铺盖、干粮爬一个月的楼梯，害人不浅。其实，我们在日常生活中也能看到不少“没头脑”的作品。工程师需要构建的一定是一个系统。系统一定需要 全面、整体、有机的设计，不能有缺陷与差错。切忌成为“没头脑”的工程师。&lt;/p&gt;
&lt;p&gt;在微软，与唐朝晖博士等合作开发了SQL Server 2005中的文本数据挖掘功能。其中的Term Extraction工具可以从数据库中的英文文本中自动抽取名词短语。这个工具的输入通常是英文文本，看似单一，但设计这个工具时，必须考虑处理其他非 正常输入，应对所有可能，比如，乱码、非英文、特殊字符、全文本大写、不含标点符号文本，等等。记得开发团队一起构建了一张巨大的逻辑图表，将所有可能的 输入列出，准备处理方案，力图做到“兵来将挡，水来土掩”。这个项目确实锻炼了大家系统解决问题的能力。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;站在用户角度看问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;苹果公司的产品，如iPad，用户界面非常简单、直观与易用。据说两岁的儿童也能无师自通，自如地使用iPad。理由很简单，苹果的产品都是为用户着想，站 在用户的角度上设计的。正是因为如此，苹果的产品能够得到广大用户的喜爱和追捧。道理虽然简单，但我们会发现，许多工程师在开发系统时常常做不到这一点， 所以做出的东西，根本不好用。&lt;/p&gt;
&lt;p&gt;在NEC参加的第一个项目是个失败的项目。目标是开发自然语言的用户界面，自动将用户输入的日语问句转换成 SQL语句，以便让普通用户很方便地访问数据库。这个项目的初衷很好，但面临的最大挑战是，语言的表现力极其强大，同样一个意思，可以有许多种不同的说法。开发到最后，系统只能接受受限的自然语言输入（当时还没有基于统计学习解决问题的想法，也许可以通过大数据、统计学习的方法在一定程度上能够解决这个问题，这也是自然语言处理今后研究的一个方向）。拿给用户使用，反馈非常差，因为对用户来说掌握受限的自然语言比掌握SQL语言还要困难。没有能站在用户 的角度上考虑问题导致了项目的失败。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;以最小代价获得最大效益&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;汽车大王福特曾说：“对实业家来说，一条重要法则就是尽可能地以最低的代价生产出最高质量的产品，给工人发出最高的工资。”福特公司1908年出的 Model T汽车价格是825美元，当时没有多少人能够买得起，到1924年Model T价格降到290美元，成为一款大众车，在美国每两台售出的汽车中就有一台是Model T。&lt;/p&gt;
&lt;p&gt;其原因是福特公司导入了生产流水线，大大地降低了生产成本。在流水线上，Model T的零部件被标准化，维修成本也大幅下降。工程与其他领域（如科学、艺术）的不同在于它必须考虑代价，包括开发的代价、推广的代价、使用的代价和维护的代 价。工程师开发系统与工具时，必须权衡效益与代价，力图以最小的代价获得最大的效益。&lt;/p&gt;
&lt;p&gt;我在微软参与了Office 2007、Office 2010、Office 2012中SharePoint的开发，具体从事元数据抽取与企业搜索功能的开发。我所在的研究团队开发了文件元数据自动抽取工具，有两种方法实 现：CRF与SVM。CRF的精度比SVM高1个百分点，但就抽取部分的代码量而言，CRF是SVM的若干倍。找SharePoint的架构师 Meyerzon商量，到底采用哪种方法好？Meyerzon毫不犹豫地答道：当然选SVM，因为它的精度只低1个百分点，但所需开发维护的代码量却少得 多。对产品来说，开发的代价是不能不考虑的因素。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;磨在细处&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对工程师而言，上帝就存在于细处！只有精雕细琢、潜心造作，才能做好工程项目。好的系统与工具是靠一点一滴打磨出来的。工程师必须在实际工作中不断磨练自己的技能，以达到手艺精湛、技术娴熟的境地，能够像庖丁一样游刃有余地解牛，像卖油翁一样点滴不溅地倒油。&lt;/p&gt;
&lt;p&gt;在NEC期间，一起工作的工程开发团队的负责人叫滨田，从他那里学到了许多编程的技能。特别是在他指导下，开发了文本数据分析系统TopicScope中的核心算法。我不是编程高手，编程只有普通程序员水平，但同事们都说我的代码写得很好，条理清晰，结构合理，内容精炼。&lt;/p&gt;
&lt;p&gt;这是因为我在滨田的影响下，花了很多功夫写代码。对项目的设置、文件的分配都反复斟酌，函数、变量的命名都细心推敲，对系统的执行效率都不断优化。写好了程序，过一段时间又拿出来检查、评价、修改，直至不能找出毛病为止（可惜加入微软以后，几乎没有时间再写代码，真希望今后能做一些编程工作）。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;从实际工作做起&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上这些原则都很简单，但真正做好却并不容易，可谓“知之非难，行之惟艰”。重要的是在实际工作中努力依照这些原则去做，养成成为优秀工程师的习惯。培养自己直接解决问题，系统地解决问题，从用户的角度解决问题，考虑效益与代价解决问题的能力。不断提高自己的专业技能，在工作中努力做好细节。你一定知道一些优秀的工程师，他们甚至就在身边，可以把他们作为榜样，虚心向他们请教，学习他们的长处，不断提高自己作为工程师的素质和能力。另外，敢于尝试，不怕失 败，在失败中及时吸取教训，总结经验也是非常重要的。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;结束语&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有人说汉字的“工”，上面一横代表天，下面一横代表地，整体表示顶天立地的事业（较一般的说法是，象形汉字的“工”代表工具）。能做好工程，成为优秀的工程师的确是一件了不起的事儿。特撰写本文，与大家共勉。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;作者李航，华为诺亚方舟实验室首席科学家。曾任职于日本NEC、微软亚洲研究院。研究方向包括信息检索、自然语言处理、统计机器学习及数据挖掘等。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.programmer.com.cn/15074/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;本文选自《程序员》杂志2013年3期，未经允许不得转载。如需转载请联系 market@csdn.net&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dingyue.programmer.com.cn/&quot; target=&quot;_blank&quot;&gt;《程序员》2013年杂志订阅送好礼活动火热进行中&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/724345682/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15606/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15606/feed/</wfw:commentRss><slash:comments>1</slash:comments><description>文/李航 华为诺亚方舟实验室首席科学家李航结合自己的亲身经验，提出了成为优秀工程师应该遵循的五项原则：面对问题，解决问题；系统地解决问题；站在用户角度看问题；以最小的代价获得最大的效益；磨在细处。 我一直在IT企业的研究部门任职，迄今经历了三家公司：NEC、微软、华为。工作都是既有基础研究，又有产品开发。其实，这两者既有密切联系，性质上又迥然不同。前者在于发现或发明普适性的理论与方法，后者在于开发实用性的系统与工具。可以说，前者需要的思维方式、基本技能与素质是科学家的，而后者是工程师的。我经常提醒自己，一定要明确在具体项目中自己到底带着什么“帽子”在工作，是科学家，还是工程师？ 我曾经将如何成为优秀科学家的体会整理成若干篇博文发表，而本文来谈谈如何成为优秀工程师的一些心得。我认为，做工程时应该遵循五项原则，并在实际的工作中把它们作为行为 指南。这些原则是：面对问题、解决问题，系统地解决问题，站在用户角度看问题，以最小的代价获得最大的效益，磨在细处。在这里做一总结，仅供大家参考。 面对问题，解决问题 西方有句谚语：“当手中拿着榔头的时候，你会觉得看到的东西都像是钉子”。根据自己的喜好、特长、习惯来解决问题是工程师的大忌。做工程时最重要的是要面对问题、解决问题。可取的策略应该是探明问题的本质，弄清问题的机理，用最直接、最有效的办法解决问题。经验告诉我们，拐弯抹角地解决问题，效果总是不好的。做工程时并不一定需要理论。只要能够有效地解决问题，其实什么方法都行。“不管白猫黑猫，捉住老鼠就是好猫”在这里也是适用的。当然有理论指导的方法 往往更能抓住问题的本质，以其为工具常常能把问题解决得更好。 在NEC工作时，我曾参加一个自然语言研究小组的立项会议。他们建议开发语音 系统来帮助用户遥控电视机，因为现在的遥控器操作都过于复杂，不利于老人与儿童使用。用语音声控电视，当然是很好的想法，现在仍有许多企业在进行这项应用 的开发。印象特别深的是他们断言，除了通过语音的办法，不存在其他解决方案。当时，我也认为他们的想法很有道理。 不料，没过几个月，日本的其他几家电器公司推出了用编码遥控电视的方法，更简单、更实用。遥控器的操作主要靠数字输入，每个电视节目都配上一个编码，报纸每天将编码在电视节目栏中公布，用户只要输入编码即可观看或录制相应的节目。 这件事对我的内心产生了很大的震动，自问为什么NEC的同事们只想到自然语言这条路，而忽视了其他路？不正是因为他们手里拿着自然语言这个榔头的缘故吗？ 系统地解决问题 动画片《没头脑与不高兴》描写了两位少年：“没头脑”与“不高兴”。“没头脑”做起事来总是丢三落四，“不高兴”待人处事总爱别别扭扭。不久，“没头脑”当上了工程师，“不高兴”当上了演员。“没头脑”设计了一座一百九十九层高的少年宫，楼建好以后，才发现忘记了设计电梯。孩子们为了在这个大楼顶层的剧院看 戏，需要带着铺盖、干粮爬一个月的楼梯，害人不浅。其实，我们在日常生活中也能看到不少“没头脑”的作品。工程师需要构建的一定是一个系统。系统一定需要 全面、整体、有机的设计，不能有缺陷与差错。切忌成为“没头脑”的工程师。 在微软，与唐朝晖博士等合作开发了SQL Server 2005中的文本数据挖掘功能。其中的Term Extraction工具可以从数据库中的英文文本中自动抽取名词短语。这个工具的输入通常是英文文本，看似单一，但设计这个工具时，必须考虑处理其他非 正常输入，应对所有可能，比如，乱码、非英文、特殊字符、全文本大写、不含标点符号文本，等等。记得开发团队一起构建了一张巨大的逻辑图表，将所有可能的 输入列出，准备处理方案，力图做到“兵来将挡，水来土掩”。这个项目确实锻炼了大家系统解决问题的能力。 站在用户角度看问题 苹果公司的产品，如iPad，用户界面非常简单、直观与易用。据说两岁的儿童也能无师自通，自如地使用iPad。理由很简单，苹果的产品都是为用户着想，站 在用户的角度上设计的。正是因为如此，苹果的产品能够得到广大用户的喜爱和追捧。道理虽然简单，但我们会发现，许多工程师在开发系统时常常做不到这一点， 所以做出的东西，根本不好用。 在NEC参加的第一个项目是个失败的项目。目标是开发自然语言的用户界面，自动将用户输入的日语问句转换成 SQL语句，以便让普通用户很方便地访问数据库。这个项目的初衷很好，但面临的最大挑战是，语言的表现力极其强大，同样一个意思，可以有许多种不同的说法。开发到最后，系统只能接受受限的自然语言输入（当时还没有基于统计学习解决问题的想法，也许可以通过大数据、统计学习的方法在一定程度上能够解决这个问题，这也是自然语言处理今后研究的一个方向）。拿给用户使用，反馈非常差，因为对用户来说掌握受限的自然语言比掌握SQL语言还要困难。没有能站在用户 的角度上考虑问题导致了项目的失败。 以最小代价获得最大效益 汽车大王福特曾说：“对实业家来说，一条重要法则就是尽可能地以最低的代价生产出最高质量的产品，给工人发出最高的工资。”福特公司1908年出的 Model T汽车价格是825美元，当时没有多少人能够买得起，到1924年Model T价格降到290美元，成为一款大众车，在美国每两台售出的汽车中就有一台是Model T。 其原因是福特公司导入了生产流水线，大大地降低了生产成本。在流水线上，Model T的零部件被标准化，维修成本也大幅下降。工程与其他领域（如科学、艺术）的不同在于它必须考虑代价，包括开发的代价、推广的代价、使用的代价和维护的代 价。工程师开发系统与工具时，必须权衡效益与代价，力图以最小的代价获得最大的效益。 我在微软参与了Office 2007、Office 2010、Office 2012中SharePoint的开发，具体从事元数据抽取与企业搜索功能的开发。我所在的研究团队开发了文件元数据自动抽取工具，有两种方法实 现：CRF与SVM。CRF的精度比SVM高1个百分点，但就抽取部分的代码量而言，CRF是SVM的若干倍。找SharePoint的架构师 Meyerzon商量，到底采用哪种方法好？Meyerzon毫不犹豫地答道：当然选SVM，因为它的精度只低1个百分点，但所需开发维护的代码量却少得 多。对产品来说，开发的代价是不能不考虑的因素。 磨在细处 对工程师而言，上帝就存在于细处！只有精雕细琢、潜心造作，才能做好工程项目。好的系统与工具是靠一点一滴打磨出来的。工程师必须在实际工作中不断磨练自己的技能，以达到手艺精湛、技术娴熟的境地，能够像庖丁一样游刃有余地解牛，像卖油翁一样点滴不溅地倒油。 在NEC期间，一起工作的工程开发团队的负责人叫滨田，从他那里学到了许多编程的技能。特别是在他指导下，开发了文本数据分析系统TopicScope中的核心算法。我不是编程高手，编程只有普通程序员水平，但同事们都说我的代码写得很好，条理清晰，结构合理，内容精炼。 这是因为我在滨田的影响下，花了很多功夫写代码。对项目的设置、文件的分配都反复斟酌，函数、变量的命名都细心推敲，对系统的执行效率都不断优化。写好了程序，过一段时间又拿出来检查、评价、修改，直至不能找出毛病为止（可惜加入微软以后，几乎没有时间再写代码，真希望今后能做一些编程工作）。 从实际工作做起 以上这些原则都很简单，但真正做好却并不容易，可谓“知之非难，行之惟艰”。重要的是在实际工作中努力依照这些原则去做，养成成为优秀工程师的习惯。培养自己直接解决问题，系统地解决问题，从用户的角度解决问题，考虑效益与代价解决问题的能力。不断提高自己的专业技能，在工作中努力做好细节。你一定知道一些优秀的工程师，他们甚至就在身边，可以把他们作为榜样，虚心向他们请教，学习他们的长处，不断提高自己作为工程师的素质和能力。另外，敢于尝试，不怕失 败，在失败中及时吸取教训，总结经验也是非常重要的。 结束语 有人说汉字的“工”，上面一横代表天，下面一横代表地，整体表示顶天立地的事业（较一般的说法是，象形汉字的“工”代表工具）。能做好工程，成为优秀的工程师的确是一件了不起的事儿。特撰写本文，与大家共勉。 [...]&lt;img src=&quot;http://www1.feedsky.com/t1/724345682/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15606/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>工程师</category><category>管理</category><pubDate>Wed, 20 Mar 2013 21:53:32 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15606/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15606</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15606/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/724345682/6222641</fs:itemid></item><item><title>数据包分析技术与网络基础</title><link>http://www.programmer.com.cn/15618/</link><content:encoded>&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;文/&lt;/strong&gt;&lt;strong&gt;Chris Sanders&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在计算机网络中，每天都可能发生成千上万的问题，从简单的间谍软件感染，到复杂的路由器配置错误。我们永远也不可能立即解决所有问题，而只能期盼充分地准备好相关的知识和工具，从而能够快速地响应各种类型的错误。所有的网络问题都源于数据包层次，即使是有着最漂亮外表的应用程序，它们也可能是“金玉其外”但“败絮其中”，有着混乱的设计与糟糕的实现，又或是看起来是可信的，但背地里在搞些恶意的行为。&lt;img class=&quot;aligncenter size-full wp-image-15642&quot; title=&quot;封面&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/30236.jpg.png&quot; alt=&quot;&quot; width=&quot;119&quot; height=&quot;150&quot; /&gt;&lt;span id=&quot;more-15618&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了更好地了解网络问题，我们需要进入到数据包层次。在这一层次，没有任何东西能够逃出我们的视线范围—这里不再有那些令人误解的菜单栏、用来吸引眼球的动画、以及无法让人信赖的员工。在数据包层次上，就不再有真正的秘密（加密通信除外），我们在数据包层次上做得越多，那我们就能够对网络有更好的控制，就能够更好更快地解决网络问题。这就是数据包分析的世界。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;数据包分析与数据包嗅探器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据包分析，通常也被称为数据包嗅探或协议分析，指的是捕获和解析网络上在线传输数据的过程，通常目的是为了能更好地了解网络上正在发生的事情。数据包分析过程通常由数据包嗅探器来执行。而数据包嗅探器则是一种用来在网络媒介上捕获原始传输数据的工具。数据包分析技术可以通过以下方法来达到目标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解网络特征。&lt;/li&gt;
&lt;li&gt;查看网络上的通信主体。&lt;/li&gt;
&lt;li&gt;确认谁或是哪些应用在占用网络带宽。&lt;/li&gt;
&lt;li&gt;识别网络使用的高峰时间。&lt;/li&gt;
&lt;li&gt;识别可能的攻击或恶意活动。&lt;/li&gt;
&lt;li&gt;寻找不安全以及滥用网络资源的应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前市面上有着多种类型的数据包嗅探器，包括免费的和商业的。每个软件的设计目标都会有一些差异。流行的数据包分析软件包括&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;tcpdump&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OmniPeek&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Wireshark&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;（我们在这本书中将只使用此款软件）。&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;tcpdump&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是个命令行程序，而&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Wireshark&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OmniPeek&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;都拥有图形用户界面（&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;GUI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;评估数据包嗅探器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你需要选择一款数据包嗅探器时，需要考虑的因素很多，包括以下内容。&lt;/p&gt;
&lt;p&gt;支持的协议：数据包嗅探器对协议解析的支持范围各不相同，大部分通常都能解析常见的网络协议（如&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IPv4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;ICMP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）、传输层协议（如&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;UDP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;），甚至一些应用层协议（如&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;DNS&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;HTTP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）。然而，它们可能并不支持一些非传统协议或新协议（如&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IPv6&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SMBv2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SIP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;等）。在选择一款嗅探器时，需要确保它能够支持你所要用到的协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用户友好性：考虑数据包嗅探器的界面布局、安装的容易度，以及操作流程的通用性。你选择的嗅探器应该适合你的专业知识水平。如果你的数据包分析经验还很少的话，你可能需要避免选择那些命令行的嗅探器，比如&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;tcpdump&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。另一方面，如果你拥有丰富的经验，你可能会觉得这类命令行程序会更具有吸引力。在你逐步积累数据包分析经验时，你甚至会发现组合使用多种数据包嗅探器软件将更有助于适应特定的应用场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;费用：关于数据包嗅探器最伟大的事情是有着很多能够与任何商业产品相媲美的免费工具。商业产品与其他替代品之间最显著的区别是它们的报告引擎，商业产品通常包括各种花哨的报告生成模块，而在免费软件中则通常缺乏，甚至没有该模块。&lt;/p&gt;
&lt;p&gt;技术支持：即使你已经掌握了嗅探软件的基本用法，但是你还是偶尔会在遇到一些新问题时需要技术支持。在评估技术支持时，你可以寻找开发人员文档、公众论坛和邮件列表。虽然对于一些像&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Wireshark&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;这样的免费软件可能缺乏一些开发人员文档，但使用这些应用软件的社区往往可以填补这些空白。使用者和贡献者社区会提供一些讨论区、维基、博客，来帮助你获得更多关于数据包嗅探器的使用方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;操作系统支持：遗憾的是，并不是所有的数据包嗅探器都支持所有的操作系统平台。你需要选择一款嗅探器，能够支持所有你将要使用的操作系统。如果你是一位顾问，你可能需要在大多数操作系统平台上进行数据包捕获和分析，那么你就需要一款能够在大多数操作系统平台上运行的嗅探器。你还需要留意，你有时会在一台机器上捕获数据包，然后在另一台机器上分析它们。操作系统之间的差异，可能会迫使你在不同的设备上使用不同的嗅探器软件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据包嗅探器工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据包嗅探过程中涉及到软件和硬件之间的协作。这个过程可以分为成&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;个步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一步：收集，数据包嗅探器从网络线缆上收集原始二进制数据。通常情况下，通过将选定的网卡设置成混杂模式来完成抓包。在这种模式下，网卡将抓取一个网段上所有的网络通信流量，而不仅是发往它的数据包。&lt;/p&gt;
&lt;p&gt;第二步：转换，将捕获的二进制数据转换成可读形式。高级的命令行数据包嗅探器就支持到这一步骤。到这步，网络上的数据包将以一种非常基础的解析方式进行显示，而将大部分的分析工作留给最终用户。&lt;/p&gt;
&lt;p&gt;第三步，也是最后一步：分析，对捕获和转换后的数据进行真正的深入分析。数据包嗅探器以捕获的网络数据作为输入，识别和验证它们的协议，然后开始分析每个协议的特定属性。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;网络通信原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了充分理解数据包分析技术，你必须准确掌握计算机是如何通过网络进行相互通信的。在本节中，我们将研究网络协议、开放系统互连模型（&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;模型）、网络数据帧的基础知识，以及支持网络&lt;/span&gt;通信的硬件知识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现代网络是由多种运行在不同平台上的异构系统组成的。为了使它们之间能够相互通信，我们使用了一套共同的网络语言，并称之为协议。常见的网络协议包括传输控制协议（&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）、互联网协议（&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）、地址解析协议（&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;ARP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）和动态主机配置协议（&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;DHCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）。协议栈是一组协同工作的网络协议的逻辑组合。&lt;/span&gt;理解网络协议的最佳途径之一是将它们想象成人类口头或书面语言的使用规则。每一种语言都有规则，如动词应该如何结合，人们该如何问候，甚至该如何礼貌地致谢。网络协议大多也是以同样方式进行工作的。它帮助我们定义如何路由数据包，如何发起一个连接，以及如何确认收到的数据。一个网络协议可以非常简单，也可能非常复杂，这取决于它的功能。尽管各种协议往往有着巨大的差异，但它们通常用来解决以下问题。&lt;/p&gt;
&lt;p&gt;发起连接：是由客户端还是服务器发起连接？在真正通信之前必须要交换哪些信息？&lt;/p&gt;
&lt;p&gt;协商连接参数：通信需要进行协议加密吗？加密密钥如何在通信双方之间进行传输？&lt;/p&gt;
&lt;p&gt;数据格式：通信数据在数据包中如何排列？数据到达接收设备时以什么样的顺序进行处理？&lt;/p&gt;
&lt;p&gt;错误检测与校正：当数据包花了太长的时间才到达目的地时如何处理？当客户端暂时无法和服务器建立通信时，该如何恢复连接？&lt;/p&gt;
&lt;p&gt;连接终止：一台主机如何告知另一台主机通信已经结束？为了礼貌地终止通信，应该传送什么样的最终信息？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七层OSI参考模型&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15622&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 216px&quot;&gt;&lt;img class=&quot;size-full wp-image-15622&quot; title=&quot;图1-1  OSI参考模型的七层协议视图&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名1.jpg&quot; alt=&quot;&quot; width=&quot;206&quot; height=&quot;428&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-1 OSI参考模型的七层协议视图&lt;/p&gt;&lt;/div&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;网络协议是基于它们在行业标准&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型中的职能进行分层的。&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;模型将网络通信过程分为&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;7&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;个不同层次，如图&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-1&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;所示。这个分层模型使得我们更容易理解网络通信。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;顶端的应用层表示用来访问网络资源的实际程序。底层则是物理层，通过它来进行实际的网络数据传播。每一层次上的网络协议共同合作，来确保通信数据在协议上层或下层中得到妥善处理。&lt;/p&gt;
&lt;p&gt;OSI&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型中的每层都具有特定功能，具体如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;应用层（第7层）：&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型的最上层，为用户访问网络资源提供一种手段。这通常是唯一一层能够由最终用户看到的协议，因为它提供的接口是最终用户所有网络活动的基础。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;表示层（第6层）：这一层将接收到的数据转换成应用层可以读取的格式。在表示层完成的数据编码与解码取决于发送与接收数据的应用层协议。表示层同时进行用来保护数据的多种加密与解密操作。&lt;/p&gt;
&lt;p&gt;会话层（第 5 层）：这一层管理两台计算机之间的对话（会话），负责在所有通信设备之间建立、管理和终止会话连接。会话层还负责以全双工或者半双工的方式来创建会话连接，在通信主机间礼貌地关闭连接，而不是粗暴地直接丢弃。&lt;/p&gt;
&lt;p&gt;传输层（第4层）：传输层的主要目的是为较低层提供可靠的数据传输服务。通过流量控制、分段／重组、差错控制等机制，传输层确保网络数据端到端的无差错传输。因为确保可靠的数据传输极为烦琐，因此&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型将其作为完整的一层。传输层同时提供了面向连接和无连接的网络协议。某些防火墙和代理服务器也工作在这一层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;网络层（第3层）：这一层负责数据在物理网络中的路由转发，是最复杂的&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层之一。它除了负责网络主机的逻辑寻址（例如通过一个&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;地址）外，还处理数据包分片和一些情况下的错误检测。路由器工作在这一层上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据链路层（第2层）：这一层提供了通过物理网络传输数据的方法，其主要目的是提供一个寻址方案，可用于确定物理设备（例如&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;MAC&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;地址）。网桥和交换机是工作在数据链路层的物理设备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;物理层（第1层）：&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型的底层是传输网络数据的物理媒介。这一层定义了所有使用的网络硬件设备的物理和电气特性，包括电压、集线器、网络适配器、中继器和线缆规范等。物理层建立和终止连接，并提供一种共享通信资源的方法，将数字信号转换成模拟信号传输，并反过来将接收的模拟信号转换回数字信号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;表&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-1&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;列出了&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型各个层次上的一些常见网络协议。&lt;/span&gt;虽然&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型仅仅是一个建议标准，你还是应该将其牢记在心。当我们阅读本书时，你发现，对不同层网络协议进行交互才能解决你面对的网络问题。例如遇到路由器问题，你该很快确认这是个“第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层上的问题”，而应用软件问题则被识别为“第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;7&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层上的问题”。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15623&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 577px&quot;&gt;&lt;img class=&quot; wp-image-15623 &quot; title=&quot;表1-1  OSI参考模型各个层次上的典型网络协议&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名2.jpg&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;207&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;表1-1 OSI参考模型各个层次上的典型网络协议&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;那网络数据是如何流经&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型的各个层次呢？在网络上传输的初始数据首先在传输网络的应用层开始，沿着&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型的七层逐层向下，直到物理层。在物理层上，传输系统将数据发送到接收系统。接收系统从它的物理层获取传输数据，然后向上逐层处理，直到最高的应用层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型任意层次上由不同协议提供的服务并不是多余的。例如，如果某层上的一个网络协议提供了一种服务，那么再没有任何其他层的协议将提供与之完全相同的服务。不同层次的协议可能有目标类似的功能，但它们会以不同的方式来实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;发送和接收计算机相同层上的网络协议是相互配合的。例如，发送系统在第&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;7&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层的某个协议是负责对传输数据进行加密的，那么往往在接收系统的第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;7&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层有着相应的网络协议，负责对网络数据进行解密。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;中连接了两个通信端图形化地说明了&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型。你可以看到，通信数据会从一个通信端的顶部流向底部，然后当它到达另一通信端时，将反向从底部流向顶部。&lt;/span&gt;OSI&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型中的每一层只能和直接的上层与下层进行通信。例如，第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层只能从第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层与第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层发送和接收数据。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15624&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 404px&quot;&gt;&lt;img class=&quot; wp-image-15624 &quot; title=&quot;图1-2  处于发送系统和接收系统同一层的协议&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名3.jpg&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;386&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-2 处于发送系统和接收系统同一层的协议&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;数据封装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OSI&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型不同层次上的协议在数据封装的帮助下进行通信传输。协议栈中的每层协议都负责在传输数据上增加一个协议头部或尾部，其中包含了使协议栈之间能够进行通信的额外信息。例如，当传输层从会话层接收数据时，它会在将数据传递到下一层之前，增加自己的头部信息数据。&lt;/span&gt;数据封装过程将创建一个协议数据单元（&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;PDU&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;），其中包括正在发送的网络数据，以及所有增加的头部与尾部协议信息。随着网络数据沿着&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型向下流动，&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;PDU&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;逐渐变化和增长，各层协议均将其头部或尾部信息添加进去，直到物理层时达到其最终形式，并发送给目标计算机。接收计算机收到&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;PDU&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;后，沿着&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型往上处理，逐层剥去协议头部和尾部，当&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;PDU&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;到达&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型的最上层时，将只剩下原始传输数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;理解数据封装过程可能会有点困难，让我们看一个实际的例子，看数据包是如何在&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型中被创建、传输和接收的。作为数据包分析师，你需要了解，我们经常会忽略掉会话层和表示层，所以它们将不会在这个例子中出现（包括本书的其余部分）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假设这样一个情形：我们试着在计算机上浏览 &lt;a href=&quot;http://www.google.com/&quot; target=&quot;_blank&quot;&gt;http://www.google.com/&lt;/a&gt;。在这个过程中，我们首先必须产生一个请求数据包，从客户端计算机传输到目标服务器上。这里我们假设&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP/IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;通信会话已经被建立，图&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;所示为此案例中的数据封装处理过程。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15628&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 576px&quot;&gt;&lt;img class=&quot; wp-image-15628 &quot; title=&quot;图1-3  客户端和服务器之间数据封装过程示意图&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名4.jpg&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;352&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-3 客户端和服务器之间数据封装过程示意图&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;我们从客户端计算机的应用层开始，在我们浏览一个网站时，所使用的应用层协议是&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;HTTP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，通过此协议发出请求命令，从&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;google.com&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;下载&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;index.html&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;文件。一旦我们的应用层协议已经确定我们要完成的任务，我们现在关心的是数据包如何发送到目的地。数据包中封装的应用层数据将沿着协议栈传递给传输层。&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;HTTP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是一个使用&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;（或在&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;协议之上）的应用层协议，因此传输层中将使用&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;协议来确保数据包的可靠投递。所以一个包括序列号和其他数据的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;协议头部将被创&lt;/span&gt;建，并被添加到数据包中，以确保数据包能够被正确交付。&lt;/p&gt;
&lt;p&gt;在完成这项工作之后，&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;协议将数据包交给&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;协议，也就是在第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层上负责为数据包进行逻辑寻址的协议。&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;协议创建一个包含有逻辑寻址信息的头部，并将数据包传递给数据链路层上的以太网，然后以太网物理地址会被添加并存储在以太网帧头中。现在数据包已经完全封装好，然后传递给物理层，在这里数据包变成&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;0&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;信号通过网络完成传输。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;封装好的数据包将穿越网络线缆，最终到达&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Google&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;服务器。&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;服务器开始读取数据包，从下往上，这意味着它首先读取数据链路层，从中提取到所包含的物理以太网寻址信息，确定数据包是否是发往这台服务器的。一旦处理完这些信息，第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层头部与尾部的信息将被剥除，并进入第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层的信息处理过程中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;读取&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;寻址信息的方式和第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层相同，目的是确认数据包被正确转发，以及数据包未进行分片处理。这些数据也同样被剥离，并交到下一层进行处理。&lt;/span&gt;现在第&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;协议信息被读取，以确保数据包是按序到达的。然后第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层报头信息被剥离，留下的只有应用层数据。这些数据会被传递到&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;服务器应用程序。为了响应客户端发过来的这个数据包，服务器应该发回一个&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;TCP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;确认数据包，使客户端知道它的请求已经被接收，并可以等待获取&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;index.html&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;文件内容了。&lt;/span&gt;所有数据包都会以这个例子中描述的过程进行创建和处理，而无论使用的是哪种协议。但同时，请牢记并非每个网络数据包都是从应用层协议产生的，所以你会进一步看到只包含第&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层、第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层或第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层协议信息的数据包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2.4  网络硬件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在是时候来看看网络硬件了，至此脏活累活都已经完成，接下来的内容都很简单了。我们将专注于几种较为常见的网络硬件：集线器、交换机和路由器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集线器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集线器一般是提供了多个&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;RJ-45&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;端口的机盒，就像图&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;所示的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;NETGEAR&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;集线器。集线器从非常小的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;端口的设备，到企业环境中安装机架设计的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;48&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;端口机盒设备，变化很大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为集线器会产生很多不必要的网络流量，并仅在半双工模式下运行（不能在同一时间发送和接收数据），所以你通常不会在现代或高密度的网络中再看到它们的身影了（用交换机来代替）。然而，你应该知道集线器的工作机制，因为它们对于数据包分析技术非常重要，特别在实施我们将于第&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;章介绍的“枢纽”技术时。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15630&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 378px&quot;&gt;&lt;img class=&quot; wp-image-15630 &quot; title=&quot;图1-4  一台典型的4端口以太网集线器&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名5.jpg&quot; alt=&quot;&quot; width=&quot;368&quot; height=&quot;144&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-4 一台典型的4端口以太网集线器&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;一台集线器无非就是工作在&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型物理层上的转发设备。它从一个端口接收到数据包，然后将数据包传输（中继）到设备的其他每个端口上。例如，如果一台计算机连接到一个&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;端口集线器的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;号端口上，需要发送数据到连接在&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;号端口的计算机，那么集线器将会把数据发送给端口&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。连接到&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;号端口与&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;号端口上的客户端计算机通过检查以太网帧头字段中的目标媒体访问控制（&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;MAC&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）地址，判断出这些数据包并不是给它们的，便丢弃这些数据包。图&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-5&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;所示为从计算机&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;发送数据到计算机&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;B&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的例子，当计算机&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;发送出数据时，所有连接到集线器的计算机都将接收到数据，但只有计算机&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;B&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;会实际接受数据，而其他计算机则将丢弃它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;div id=&quot;attachment_15631&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 457px&quot;&gt;&lt;img class=&quot;size-full wp-image-15631&quot; title=&quot;图1-5  计算机A通过集线器传输数据到计算机B的通信流&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名6.jpg&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;385&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-5 计算机A通过集线器传输数据到计算机B的通信流&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;&lt;span style=&quot;font-family: 楷体_GB2312;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;做一个比喻，假设你发送一封主题为“所有的营销人员请注意”的电子邮件给贵公司所有雇员，而不只是那些在营销部门工作的人。市场营销部门的员工会知道这封邮件是给他们的，他们很可能会打开它，而其他员工将看到这封邮件并不是给他们的，则很可能会选择丢弃。你可以看到这会导致很多不必要的通信和时间浪费，然而这正是集线器的工作原理。在高密度的实际网络中，集线器最好的替代产品是交换机，它们是支持全双工的设备，可以同步地发送和接收数据。·  交换机与集线器相同，交换机也是用来中继数据包的。但与集线器不同的是，交换机并不是将数据广播到每一个端口，而是将数据发送到目的计算机所连接的端口上。如同你在图&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-6&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;中看到的那样，交换机的外表与集线器没什么两样。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15634&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 527px&quot;&gt;&lt;img class=&quot; wp-image-15634 &quot; title=&quot;图1-6  一个机架式24端口以太网交换机&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名7.jpg&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;163&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-6 一个机架式24端口以太网交换机&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;市场上几个大牌公司的交换机，比如思科品牌的，能够通过专业化的供应商特定软件或&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;接口进行远程管理。这些交换机通常被称为管理型交换机。管理型交换机提供了多种在网络管理中非常有用的功能特性，包括启用或禁用特定端口、查看端口细节参数、远程修改配置、远程重启等。&lt;/span&gt;交换机在涉及处理传输数据包时，还提供一些先进的功能。为了能够直接与一些特定设备进行通信，交换机必须能够通过&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;MAC&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;地址来唯一标识设备，这意味着它们必须工作在&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型的数据链路层上。&lt;/span&gt;交换机将每个连接设备的第&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层地址都存储在一个&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;CAM&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;（&lt;/span&gt;Content Addressable Memory即内容寻址寄存器）表中，&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;CAM&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;表充当着一种类似交通警察的角色。当一个数据包被传输时，交换机读取数据包中的第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层协议头部信息，并使用&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;CAM&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;表作为参考，决定往哪个或哪些端口发送数据包。交换机仅仅将数据包发送到特定端口上，从而大大降低了网络流量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;div id=&quot;attachment_15635&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 368px&quot;&gt;&lt;img class=&quot; wp-image-15635 &quot; title=&quot;图1-7  当计算机A通过交换机传输数据到计算机B时的通信流示意图&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名8.jpg&quot; alt=&quot;&quot; width=&quot;358&quot; height=&quot;302&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-7 当计算机A通过交换机传输数据到计算机B时的通信流示意图&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;在这个图示中，计算机&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;发送数据到唯一的目标：计算机&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;B&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，虽然同一时间网络上可能会有很多会话，但信息将会直接通过交换机向目标接收者进行传输，而不会被传递到与交换机相连的所有计算机。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;路由器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;路由器是一种较交换机或集线器具有更高层次功能的先进网络设备。一个路由器可以有许多种不同的形状和外形，但大多数路由器在前面板上会有几个&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;LED&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;指示灯，在背板上会有一些网络端口，个数则取决于网络的大小。图&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-8&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;所示为一款路由器的示例。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15636&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 390px&quot;&gt;&lt;img class=&quot; wp-image-15636 &quot; title=&quot;图1-8  一款低端的Cisco路由器，适合在一个中小型网络使用&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名9.jpg&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;196&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-8 一款低端的Cisco路由器，适合在一个中小型网络使用&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;路由器工作在&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;OSI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;参考模型的第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层，它负责在两个或多个网络之间转发数据包。路由器在网络间引导数据包流向的这一过程被称为路由。几种不同类型的路由协议定义了不同目的的数据包如何被路由到其他网络。路由器通常使用第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层地址（如&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;地址）来唯一标识网络上的设备。&lt;/span&gt;为了更清楚地解释路由的概念，我们以一个拥有几条街道的街区进行类比。假设有一些房子，它们都有着自己的地址，就好比网络上的计算机一样，而每条街道就好比网段，如图&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-9&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;从你所在街道上的某个房子，你可以很容易地与同一街道中居住的邻居进行沟通交流，这类似于交换机的操作&lt;/span&gt;，能够允许在同一网段中的所有计算机进行相互通信。然而，与其他街道上居住的邻居进行沟通交流，就像是与不同网段中的计算机进行通信。&lt;/p&gt;
&lt;div id=&quot;attachment_15637&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 458px&quot;&gt;&lt;img class=&quot; wp-image-15637 &quot; title=&quot;图1-9  一个路由网络与邻街区的类比&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名10.jpg&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;230&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-9 一个路由网络与邻街区的类比&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;参照图&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-9&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，假设你住在&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Vine Street 503&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;号，需要到&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Dogwood Lave 202&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;号。如果想要过去，你必须先到&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Oak Steer&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;上，然后再到&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Dogwood Lave&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。现在请对应到跨越&lt;/span&gt;网段的场景中，如果在&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;192.168.0.3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;地址的设备需要和&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;192.168.0.54&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;地址的设备进行通信，它必须经由路由器到&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;10.100.1.1&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;网络上，然后再经过连接目的网段的路由器才可以到达目标网段上。&lt;/span&gt;网络上路由器的数量与大小通常取决于网络的规模与功能。个人和家庭办公网络可能只需要一个小型路由器，放置在网络的中心。而大型企业网络则可能有几个路由器分布在不同的部门，都连接到一个大型的中央路由器或三层交换机上（具有内置功能，可以充当一台路由器的先进型交换机）。当你开始查看越来越多的网络图时，你会更加了解网络数据流是如何流经这些不同类型的网络设备节点，图&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-10&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;所示为路由网络中一个非常常见的布局形式。在这个例子中，两个单独的网络通过一个路由器进行连接。如果网络&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;A&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;上的计算机希望与网络&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;B&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;上的计算机进行通信，传输数据将必须通过路由器。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15638&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 456px&quot;&gt;&lt;img class=&quot; wp-image-15638  &quot; title=&quot;图1-10  计算机A通过路由器将数据传送到计算机X的通信流示意图&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名11.jpg&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;194&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-10 计算机A通过路由器将数据传送到计算机X的通信流示意图&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;流量分类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;网络流量可以分为三大类：广播、多播和单播。每个分类都具有不同特点，决定着这一类的数据包该如何通过网络硬件进行处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广播流量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广播数据包会被发送到一个网段上的所有端口，而无论这些端口连接在集线器还是交换机上。但并非所有的广播流量都是以相同方式构建的，而是包括第&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层广播流量和第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层广播流量两种主要形式。例如，在第&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层，&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;MAC&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;地址&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;FF:FF:FF:FF:FF:FF&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是保留的广播地址，任何发送到这一地址上的流量将会被广播到整个&lt;/span&gt;网段。第&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层也有一些特定的广播地址。&lt;/span&gt;在一个&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;网络范围中最大的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;地址是被保留作为广播地址使用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;例如，在一个配置了&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;192.168.0.XXX&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;范围，以及子网掩码是&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;255.255.255.0&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的地址网络中，广播&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;地址是&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;192.168.0.255&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;在通过多个集线器或交换机连接多种媒介的大型网络中，广播数据包将被一直从一个交换机被中继到另一交换机上，从而传输到网络连接的所有网段上。广播数据包能够到达的区域被称为“广播域”，也就是任意计算机可以不用经由路由器即可和其他计算机进行直接传输的网段范围。图&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;1-11&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;显示了一个小型网络上存在两个广播域的例子。因为每个广播域会一直延伸直到路由器，而广播数据包只能在它特定的广播域中传输。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15640&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 468px&quot;&gt;&lt;img class=&quot; wp-image-15640 &quot; title=&quot;图1-11  一个广播域一直延伸到路由器后面的网段&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/TM截图未命名12.jpg&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;211&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图1-11 一个广播域一直延伸到路由器后面的网段&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;我们前面的类比也能很好地说明广播域是如何工作的。你可以将一个广播域想象成一条街道。如果你站在你家门口叫喊，只有街道上的人才能够听到你的声音。而如果你想与不同街道上的人说话，那么你需要找到一种与他进行直接交流的方式，而不是在你的家门口大喊大叫（广播）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多播流量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多播是一种将单一来源数据包同时传输给多个目标的通信方式。多播的目的是为了简化这个过程，并使用尽可能少的网络带宽。多播流量通过避免数据包的大量复制来达到优化效果，而处置多播流量的方式则高度依赖于不同网络协议的实现细节。实施多播的主要方法是通过一种将数据包接收者加入多播组的编址方案，这也是&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;多播的工作原理。这种编址方案确保数据包不会被传送到未预期的目的地。事实上&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;协议将一整段的地址都赋予了多播，如果你在网络上看到在 &lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;224.0.0.0&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;到&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;239.255.255.255 IP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;范围内的地址，它很有可能就是多播流量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单播流量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单播数据包会从一台计算机直接传输到另一台计算机。单播机制的具体实现方式取决于使用的协议。例如，一台设备希望与一个&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;服务器进行通信，这便是一个端到端的连接，所以通信过程将由客户端设备发送数据包到这台&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;服务器开始。这种类型的通信就是单播流量的典型例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;作者Chris Sanders&lt;span style=&quot;font-family: 宋体;&quot;&gt;是一名计算机安全咨询顾问、作家和研究人员。他还是一名&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SANS&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;导师，持有&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;CISSP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;GCIA&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;GCIH&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;GREM&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;等行业证书，并定期在&lt;/span&gt;&lt;a href=&quot;WindowsSecurity.com&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;font-family: Times New Roman; color: #888888;&quot;&gt;WindowsSecurity.com&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;网站和自己的博客&lt;/span&gt;&lt;a href=&quot;ChrisSanders.org&quot; target=&quot;_blank&quot;&gt;&lt;span style=&quot;font-family: Times New Roman; color: #888888;&quot;&gt;ChrisSanders.org&lt;/span&gt;&lt;/a&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;发表文章。&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Sanders&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;每天都会使用&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Wireshark&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;进行数据包分析。他目前居住在美国南卡罗米纳州查尔斯顿，以国防承包商的身份工作。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;本文节选自《Wireshark数据包分析实战(第2版)》，作者Chris Sanders, 诸葛建伟、陈霖、许伟林译，由人民邮电出版社出版。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br /&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/723865969/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15618/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15618/feed/</wfw:commentRss><slash:comments>0</slash:comments><description>文/Chris Sanders 在计算机网络中，每天都可能发生成千上万的问题，从简单的间谍软件感染，到复杂的路由器配置错误。我们永远也不可能立即解决所有问题，而只能期盼充分地准备好相关的知识和工具，从而能够快速地响应各种类型的错误。所有的网络问题都源于数据包层次，即使是有着最漂亮外表的应用程序，它们也可能是“金玉其外”但“败絮其中”，有着混乱的设计与糟糕的实现，又或是看起来是可信的，但背地里在搞些恶意的行为。 为了更好地了解网络问题，我们需要进入到数据包层次。在这一层次，没有任何东西能够逃出我们的视线范围—这里不再有那些令人误解的菜单栏、用来吸引眼球的动画、以及无法让人信赖的员工。在数据包层次上，就不再有真正的秘密（加密通信除外），我们在数据包层次上做得越多，那我们就能够对网络有更好的控制，就能够更好更快地解决网络问题。这就是数据包分析的世界。 数据包分析与数据包嗅探器 数据包分析，通常也被称为数据包嗅探或协议分析，指的是捕获和解析网络上在线传输数据的过程，通常目的是为了能更好地了解网络上正在发生的事情。数据包分析过程通常由数据包嗅探器来执行。而数据包嗅探器则是一种用来在网络媒介上捕获原始传输数据的工具。数据包分析技术可以通过以下方法来达到目标。 了解网络特征。 查看网络上的通信主体。 确认谁或是哪些应用在占用网络带宽。 识别网络使用的高峰时间。 识别可能的攻击或恶意活动。 寻找不安全以及滥用网络资源的应用。 目前市面上有着多种类型的数据包嗅探器，包括免费的和商业的。每个软件的设计目标都会有一些差异。流行的数据包分析软件包括tcpdump、OmniPeek和Wireshark（我们在这本书中将只使用此款软件）。tcpdump是个命令行程序，而Wireshark和OmniPeek都拥有图形用户界面（GUI）。 评估数据包嗅探器 当你需要选择一款数据包嗅探器时，需要考虑的因素很多，包括以下内容。 支持的协议：数据包嗅探器对协议解析的支持范围各不相同，大部分通常都能解析常见的网络协议（如IPv4和ICMP）、传输层协议（如TCP和UDP），甚至一些应用层协议（如DNS和HTTP）。然而，它们可能并不支持一些非传统协议或新协议（如IPv6、SMBv2、SIP等）。在选择一款嗅探器时，需要确保它能够支持你所要用到的协议。 用户友好性：考虑数据包嗅探器的界面布局、安装的容易度，以及操作流程的通用性。你选择的嗅探器应该适合你的专业知识水平。如果你的数据包分析经验还很少的话，你可能需要避免选择那些命令行的嗅探器，比如tcpdump。另一方面，如果你拥有丰富的经验，你可能会觉得这类命令行程序会更具有吸引力。在你逐步积累数据包分析经验时，你甚至会发现组合使用多种数据包嗅探器软件将更有助于适应特定的应用场景。 费用：关于数据包嗅探器最伟大的事情是有着很多能够与任何商业产品相媲美的免费工具。商业产品与其他替代品之间最显著的区别是它们的报告引擎，商业产品通常包括各种花哨的报告生成模块，而在免费软件中则通常缺乏，甚至没有该模块。 技术支持：即使你已经掌握了嗅探软件的基本用法，但是你还是偶尔会在遇到一些新问题时需要技术支持。在评估技术支持时，你可以寻找开发人员文档、公众论坛和邮件列表。虽然对于一些像Wireshark这样的免费软件可能缺乏一些开发人员文档，但使用这些应用软件的社区往往可以填补这些空白。使用者和贡献者社区会提供一些讨论区、维基、博客，来帮助你获得更多关于数据包嗅探器的使用方法。 操作系统支持：遗憾的是，并不是所有的数据包嗅探器都支持所有的操作系统平台。你需要选择一款嗅探器，能够支持所有你将要使用的操作系统。如果你是一位顾问，你可能需要在大多数操作系统平台上进行数据包捕获和分析，那么你就需要一款能够在大多数操作系统平台上运行的嗅探器。你还需要留意，你有时会在一台机器上捕获数据包，然后在另一台机器上分析它们。操作系统之间的差异，可能会迫使你在不同的设备上使用不同的嗅探器软件。 数据包嗅探器工作原理 数据包嗅探过程中涉及到软件和硬件之间的协作。这个过程可以分为成3个步骤。 第一步：收集，数据包嗅探器从网络线缆上收集原始二进制数据。通常情况下，通过将选定的网卡设置成混杂模式来完成抓包。在这种模式下，网卡将抓取一个网段上所有的网络通信流量，而不仅是发往它的数据包。 第二步：转换，将捕获的二进制数据转换成可读形式。高级的命令行数据包嗅探器就支持到这一步骤。到这步，网络上的数据包将以一种非常基础的解析方式进行显示，而将大部分的分析工作留给最终用户。 第三步，也是最后一步：分析，对捕获和转换后的数据进行真正的深入分析。数据包嗅探器以捕获的网络数据作为输入，识别和验证它们的协议，然后开始分析每个协议的特定属性。 网络通信原理 为了充分理解数据包分析技术，你必须准确掌握计算机是如何通过网络进行相互通信的。在本节中，我们将研究网络协议、开放系统互连模型（OSI模型）、网络数据帧的基础知识，以及支持网络通信的硬件知识。 协议 现代网络是由多种运行在不同平台上的异构系统组成的。为了使它们之间能够相互通信，我们使用了一套共同的网络语言，并称之为协议。常见的网络协议包括传输控制协议（TCP）、互联网协议（IP）、地址解析协议（ARP）和动态主机配置协议（DHCP）。协议栈是一组协同工作的网络协议的逻辑组合。理解网络协议的最佳途径之一是将它们想象成人类口头或书面语言的使用规则。每一种语言都有规则，如动词应该如何结合，人们该如何问候，甚至该如何礼貌地致谢。网络协议大多也是以同样方式进行工作的。它帮助我们定义如何路由数据包，如何发起一个连接，以及如何确认收到的数据。一个网络协议可以非常简单，也可能非常复杂，这取决于它的功能。尽管各种协议往往有着巨大的差异，但它们通常用来解决以下问题。 发起连接：是由客户端还是服务器发起连接？在真正通信之前必须要交换哪些信息？ 协商连接参数：通信需要进行协议加密吗？加密密钥如何在通信双方之间进行传输？ 数据格式：通信数据在数据包中如何排列？数据到达接收设备时以什么样的顺序进行处理？ 错误检测与校正：当数据包花了太长的时间才到达目的地时如何处理？当客户端暂时无法和服务器建立通信时，该如何恢复连接？ 连接终止：一台主机如何告知另一台主机通信已经结束？为了礼貌地终止通信，应该传送什么样的最终信息？ 七层OSI参考模型 网络协议是基于它们在行业标准OSI参考模型中的职能进行分层的。OSI模型将网络通信过程分为7个不同层次，如图1-1所示。这个分层模型使得我们更容易理解网络通信。 顶端的应用层表示用来访问网络资源的实际程序。底层则是物理层，通过它来进行实际的网络数据传播。每一层次上的网络协议共同合作，来确保通信数据在协议上层或下层中得到妥善处理。 OSI参考模型中的每层都具有特定功能，具体如下。 应用层（第7层）：OSI参考模型的最上层，为用户访问网络资源提供一种手段。这通常是唯一一层能够由最终用户看到的协议，因为它提供的接口是最终用户所有网络活动的基础。 表示层（第6层）：这一层将接收到的数据转换成应用层可以读取的格式。在表示层完成的数据编码与解码取决于发送与接收数据的应用层协议。表示层同时进行用来保护数据的多种加密与解密操作。 会话层（第 5 层）：这一层管理两台计算机之间的对话（会话），负责在所有通信设备之间建立、管理和终止会话连接。会话层还负责以全双工或者半双工的方式来创建会话连接，在通信主机间礼貌地关闭连接，而不是粗暴地直接丢弃。 传输层（第4层）：传输层的主要目的是为较低层提供可靠的数据传输服务。通过流量控制、分段／重组、差错控制等机制，传输层确保网络数据端到端的无差错传输。因为确保可靠的数据传输极为烦琐，因此OSI参考模型将其作为完整的一层。传输层同时提供了面向连接和无连接的网络协议。某些防火墙和代理服务器也工作在这一层。 网络层（第3层）：这一层负责数据在物理网络中的路由转发，是最复杂的OSI层之一。它除了负责网络主机的逻辑寻址（例如通过一个IP地址）外，还处理数据包分片和一些情况下的错误检测。路由器工作在这一层上。 数据链路层（第2层）：这一层提供了通过物理网络传输数据的方法，其主要目的是提供一个寻址方案，可用于确定物理设备（例如MAC地址）。网桥和交换机是工作在数据链路层的物理设备。 物理层（第1层）：OSI参考模型的底层是传输网络数据的物理媒介。这一层定义了所有使用的网络硬件设备的物理和电气特性，包括电压、集线器、网络适配器、中继器和线缆规范等。物理层建立和终止连接，并提供一种共享通信资源的方法，将数字信号转换成模拟信号传输，并反过来将接收的模拟信号转换回数字信号。 表1-1列出了OSI参考模型各个层次上的一些常见网络协议。虽然OSI参考模型仅仅是一个建议标准，你还是应该将其牢记在心。当我们阅读本书时，你发现，对不同层网络协议进行交互才能解决你面对的网络问题。例如遇到路由器问题，你该很快确认这是个“第3层上的问题”，而应用软件问题则被识别为“第7层上的问题”。 &amp;#160; 那网络数据是如何流经OSI参考模型的各个层次呢？在网络上传输的初始数据首先在传输网络的应用层开始，沿着OSI参考模型的七层逐层向下，直到物理层。在物理层上，传输系统将数据发送到接收系统。接收系统从它的物理层获取传输数据，然后向上逐层处理，直到最高的应用层。 在OSI参考模型任意层次上由不同协议提供的服务并不是多余的。例如，如果某层上的一个网络协议提供了一种服务，那么再没有任何其他层的协议将提供与之完全相同的服务。不同层次的协议可能有目标类似的功能，但它们会以不同的方式来实现。 发送和接收计算机相同层上的网络协议是相互配合的。例如，发送系统在第7层的某个协议是负责对传输数据进行加密的，那么往往在接收系统的第7层有着相应的网络协议，负责对网络数据进行解密。 图1-2中连接了两个通信端图形化地说明了OSI参考模型。你可以看到，通信数据会从一个通信端的顶部流向底部，然后当它到达另一通信端时，将反向从底部流向顶部。OSI参考模型中的每一层只能和直接的上层与下层进行通信。例如，第2层只能从第1层与第3层发送和接收数据。 数据封装 OSI参考模型不同层次上的协议在数据封装的帮助下进行通信传输。协议栈中的每层协议都负责在传输数据上增加一个协议头部或尾部，其中包含了使协议栈之间能够进行通信的额外信息。例如，当传输层从会话层接收数据时，它会在将数据传递到下一层之前，增加自己的头部信息数据。数据封装过程将创建一个协议数据单元（PDU），其中包括正在发送的网络数据，以及所有增加的头部与尾部协议信息。随着网络数据沿着OSI参考模型向下流动，PDU逐渐变化和增长，各层协议均将其头部或尾部信息添加进去，直到物理层时达到其最终形式，并发送给目标计算机。接收计算机收到PDU后，沿着OSI参考模型往上处理，逐层剥去协议头部和尾部，当PDU到达OSI参考模型的最上层时，将只剩下原始传输数据。 理解数据封装过程可能会有点困难，让我们看一个实际的例子，看数据包是如何在OSI参考模型中被创建、传输和接收的。作为数据包分析师，你需要了解，我们经常会忽略掉会话层和表示层，所以它们将不会在这个例子中出现（包括本书的其余部分）。 假设这样一个情形：我们试着在计算机上浏览 http://www.google.com/。在这个过程中，我们首先必须产生一个请求数据包，从客户端计算机传输到目标服务器上。这里我们假设TCP/IP通信会话已经被建立，图1-3所示为此案例中的数据封装处理过程。 [...]&lt;img src=&quot;http://www1.feedsky.com/t1/723865969/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15618/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>图书推荐</category><pubDate>Tue, 19 Mar 2013 17:24:29 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15618/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15618</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15618/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/723865969/6222641</fs:itemid></item><item><title>解密Facebook产品的开发流程</title><link>http://www.programmer.com.cn/15584/</link><content:encoded>&lt;p&gt;&lt;strong&gt;文/王淮&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;&lt;strong&gt;王淮是Facebook第二位中国籍工程师，也是第一位中国籍研发经理，他一手开创了Facebook的支付安全和客服工具领域。2011年他离开Facebook，回国成为天使投资人，希望用自己在Facebook的经验帮助创业者。王淮下周将做客CSDN，欢迎读者朋友留言，我们将挑选部分问题，在专访中邀请王淮解答。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在详细说明Facebook产品开发流程的九大步骤之前，必须先讲清楚一点，这些是我用马后炮的方式来思考自己在Facebook做产 品、项目的实践中可能出现的步骤。所谓的“流程”，在Facebook内部并不存在，这些步骤并不都是必须的。对于不同类型的项目，有些对时间要求高一些，所以更强调速度；有些对质量要求高一些，会更强调项目管理的流程（Process）。请读者在阅读时仔细斟酌，哪些符合自身的实际情况，则可以借鉴； 哪些不适合，要灵活掌握。&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;span id=&quot;more-15584&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描绘远景，设置目标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做每件事情之前都要有明确的目标，在聚焦于细节之前要有大的远景（Vision），这可以在以后的实施过程中指引方向。对于远景的思考，主要围绕以下三点。&lt;/p&gt;
&lt;p&gt;1. 为什么设这个目标，而不是另外一个？&lt;/p&gt;
&lt;p&gt;2. 在做一件事情之前，脑子里应该有这件事情完成之后是什么样子这个画面，接下来很多事情都是围绕着这个最终画面来进行的。&lt;/p&gt;
&lt;p&gt;3. 计划做些什么来实现这个远景？这就需要将最终目标具体化，变成一个可以想象的图片，甚至量化，然后才能使得最终目标容易被别人理解。&lt;/p&gt;
&lt;p&gt;那又该如何设定目标呢？在Facebook，常用的方法是遵循“SMART”规则。&lt;/p&gt;
&lt;p&gt;S——非常详细具体的（Specific）。目标必须被清晰定义，无法被混淆或者误解。&lt;/p&gt;
&lt;p&gt;M——是能够衡量的（Measurable）。只有可以被衡量的目标，才能一直清楚做得如何，离目标有多远，当前是超出还是低于预期的进度。&lt;/p&gt;
&lt;p&gt;A——要有足够的难度和挑战性（Aggressive）。容易完成的目标，很容易让员工懈怠；一旦失去战斗的激情，更谈不上发挥潜能。&lt;/p&gt;
&lt;p&gt;R——现实的（Realistic），这是对上一点的平衡。过于有难度的目标，会令员工疲惫不堪，如果最后还是没能完成任务的话，对他们的信心是非常大的打击。&lt;/p&gt;
&lt;p&gt;T——要有实现的期限（Time-bound）。没有实现期限的目标是没有意义的，因为不知道什么时候应该到达什么程度。&lt;/p&gt;
&lt;p&gt;有了目标之后，才可能有很详细的项目计划，所有的项目都应该是跟这些目标相关的。不相干的项目会分散注意力（Distraction），要坚决抵制。接下来，组里人员的绝大多数时间都要花在跟这几个目标相关的项目上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;收集想法并排出优先次序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有 了目标以后，会产生很多相关的想法（Idea），但很难判断究竟哪个想法一定能达到这些目标，也不可能把所有的想法都试一遍，往往到最后都需要有理有据地 进行“赌博”，把精力押在某几个核心的想法上。这也是Facebook要招最好的工程师的原因之一。工程师不仅要善于写程序，也要有选择想法的能力，你不 仅要对这个问题有很深入的思考，进行大量的分析，还要有胆量，能果断押注，并且有很高的命中率。&lt;/p&gt;
&lt;p&gt;那么，这些想法从何而来呢？最自然的方式就 是之前延续下来的、大家明确知道要做的项目，而那些不明确的想法，才是难点。在发展非常快的公司里，绝对不会缺少这种不明确的想法。在Facebook， 一般是由技术经理、产品经理、工程师贡献大量的想法。负责商业运营（Business Operation）的同事也会贡献一些想法。做下一个月计划时，我会在当月25日左右开始给相关人员发一个一周后的头脑风暴会议邀请，并希望他们在会议 之前把自己认为应做的或者想做的事情发邮件告诉我。我事先做分类整理，让会议进行得更加高效。当然，线下的讨论、分享等也是产生想法的好机会。&lt;/p&gt;
&lt;p&gt;接下来最为关键的就是分析想法——如何挑选出最可能产生效果的想法。理论上，如果有无限的资源，我们应该尝试所有的想法。但在Facebook，任何时候都处于资源短缺的状态，我们必须把有限的资源放到有可能产生最大价值的想法上面。&lt;/p&gt;
&lt;p&gt;这里，我要特别强调一下“Top X（只做前X项）”规则：只做对目标最有影响的前X项。我们会对所有的想法进行讨论，根据每个想法对目标的影响和其所需要的资源（主要是人力与时间—— “人周”）进行讨论，然后排序（按P0，P1，P2……的方式来），最后挑选排在最前面的几项。分析完后，对几个明显一定要做的想法很容易决定，对几个要 去掉的也很容易决定，关键是剩下的那些想法，没有足够的精力把它们都尝试一遍，这就要考验你的抉择能力了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跨团队沟通&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;决定了要做的项目之后，就需讨论如何跟其他相关组的计划对接。你当然不希望原本以为兄弟组能配合自己做一个项目时，却发现对方并未把与你项目相关的工作放入他们的计划中。这里要进行的沟通，就是让相关组之间做的事情是相辅相成的，而不是互相扯皮，造成不必要的内耗。&lt;/p&gt;
&lt;p&gt;有两类人是特别需要沟通的。&lt;/p&gt;
&lt;p&gt;1. 不同职能之间的沟通，包括工程师、产品经理、设计师，还有与项目相关的上下游团队或部门。&lt;/p&gt;
&lt;p&gt;2. 相关的工程兄弟组之间的沟通。因为大家相互之间经常有技术或者框架上的共享，我们定下要做的事情，就看看相互之间是否有可以匹配的项目，如果我们需要他们的配合，就要看怎样可以列入他们的计划。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;告知所有可能关心的人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们会召开一次最终的计划定夺会议。主要是由工程师和产品经理及一些非常相关的人参加，这种会议是小规模的，因为不想在决策时让其他非产品技术的人员参与进 来，其他人的声音已经在之前的跨团队沟通过程中被充分地考虑了。如果前面的工作准备得比较好，这种会议速度都很快，一般半个小时左右。&lt;/p&gt;
&lt;p&gt;整个计划定下来之后，会发一封邮件给所有关心该计划的人和相关工作的人。并且会在接收人那里把老板、老板的老板都放进去，以确保他们能清楚、理解并支持我们组的计划。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计产品&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于任何一个项目，具体执行中一般都涉及四个维度：功能（Feature Set），预期完成时间（Time to Market），预算（Budget，主要是人员，还有服务器、带宽资源、金钱等），完成质量（Quality，包括可扩展性Scalability、性 能Performance等）。不管你做没做计划，所有的决定都围绕着这四个方面进行考量。如果进度拖后了，那么可以去掉或精简一个功能，或者推后完成的 时间，或者增加人手、加大投入，或者降低质量等，无非就是在这四个方面进行取舍。&lt;/p&gt;
&lt;p&gt;很重要的一点是，设计产品时，要大概知道第一版本（V1）是什么样子。可以在设计时构思产品的最终状态，但公司不会允许花大量的资源去打造一个所谓的终极版本。一定要思考第一版本包含哪些功能、什么时间发布、要多少人员配置、要花多少钱做市场宣传、达到什么效果等。&lt;/p&gt;
&lt;p&gt;这可以避免一开始投入过大，但做出的产品并不是市场所需要的，再进行很大修改甚至放弃该产品的情况出现，这无疑是很大的浪费。&lt;/p&gt;
&lt;p&gt;而对于技术性的系统或框架，通常会召集相关专家开会，介绍新系统，并讨论为什么做这个系统，以及其优缺点、跟已有系统的关联。这种讨论会，相对技术性比较强，一般不会有产品经理参与（他们不大懂后台的技术），更多的是邀请有相关经验的后台工程师参加。&lt;/p&gt;
&lt;p&gt;这里要特别强调的是，Facebook非常注意不重复开发新的技术系统。一个原则是：有好的开源系统，就用开源的；有好的商用产品，就购买商用的；必须自己 开发的或者跟Facebook核心竞争力息息相关的，则集中力量开发一套，而不是重复劳动，开发多套类似系统。而对于一些跟核心数据息息相关的系统，即使 市场上有商用系统，Facebook还是会自己开发。&lt;/p&gt;
&lt;p&gt;另外，Facebook从不期望由一个人完成某个项目所有的事情。我会要求某个组员来承担某个项目的责任，但要的是让他驱动整个项目，并不代表所有的事情都完全靠他个人去做。我会要求他善于使用整个公司的力量，学会积极主动地获得别人的帮助，事半功倍地完成一个项目，同时在这个过程中获得成长。如果让其他组帮助做一些事情更加适合的话，我也会鼓励朝这个方向努力。&lt;/p&gt;
&lt;p&gt;但如果一个项目最终不成功，那么项目负责人是不能以别人无法提供帮助作为借口的。因此，即使别人答应帮忙，项目负责人还是需要学会去激励别人、监督别人，通过“抒情讲理”甚至“威逼利诱”等各种手段获得及时的帮助。&lt;/p&gt;
&lt;p&gt;但Facebook的文化鼓励只有适合寻求帮助时才这么做，属于一个项目核心的工作必须由该团队自身去完成。别人一般只能在他们的系统上给予配合或者技术上给予建议，最主要的挑战还是靠自己。也只有这样，一个团队才能真正获得成长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指定项目责任人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要为每一个项目都指定一个明确的责任人，一般都是工程师。这样做最大的好处是责任非常清楚，每一个项目都有非常清晰的拥有者（Owner），这让推脱责任变得很难。&lt;/p&gt;
&lt;p&gt;第二个好处是锻炼员工的才能。Facebook不希望初级工程师永远做螺丝钉的角色，希望每个工程师都能积极领导一项任务，推动项目进展。责任明确的项目可以“逼迫”工程师担当起责任。&lt;/p&gt;
&lt;p&gt;第三个好处是方便交流。公司里任何一位对某个项目感兴趣的同事都可以了解该项目的进展情况，项目责任人就是他交流的对象，而不需要一定要去找技术经理或者产品经理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定期碰头会&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于每一个开发中的项目，我们都要清楚地知道具体进展，因为今天做好的东西是明天的基础。根据项目的紧急性和重要程度定期讨论，可以每天都进行，也可以每周进行一两次。一般每次会议在10～30分钟，而越频繁的碰头用的时间应该越短。&lt;/p&gt;
&lt;p&gt;召开碰头会时，所有跟这个项目相关的人都要参与，围绕着这个项目把所有相关的任务及其进展迅速过一遍，每个人把自己前一天（或者前一周）完成的任务情况汇报 一下。如果遇到了困难，大家会集中讨论，帮忙解决。最好不要找一些愚蠢的借口来搪塞，这将导致原先答应的事情没有按时按质按量地完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;了解进度　汇总报告&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对负责一个团队的研发经理而言，要对自己组里正在进行的每个项目都有深入和及时的了解，知道最新进展。处于绿灯状态的，当然很好，要给予鼓励；处于黄灯状态 的，要给予适当的帮助，挪掉绊脚石，加速项目进展；处于红灯状态的，要了解为什么会这样，还能否采取相应措施补救。在行动之外，非常重要的就是反省，弄清 楚为什么没有在黄灯时及时发现并给予帮助，然后吸取教训，避免将来出现同样的失误。&lt;/p&gt;
&lt;p&gt;对战斗在第一线的团队，定期的项目碰头会可以让某个项目 的所有战斗人员都能保持对信息获取的一致性，有共同的交流基础。然而，后方人员，比如关心某个项目的同事或者老板的老板等，要了解一个项目的进展不是非常 轻松的事情。作为研发经理，我会在每周五把组里当前正在进行的所有项目的进展情况汇总到一起，形成简报，给所有关注支付产品的人发邮件，让他们都能有机会 了解到相关情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布产品　监测数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;产品完成开发之后，当然就要推出去。推出去之前，有些产品需要进行风险控制。比如，支付类的产品经常会做发布前评估（Pre-launch Review）。&lt;/p&gt;
&lt;p&gt;所谓发布前评估，就是在发布之前，根据具体的产品或者该次发布的特点，做一些诸如发布策略、需监测的核心数据、产品演示、核心算法改变等方面的讨论。在做产 品讨论时，我会要求参会的人员思考这个问题——“如果这次发布出现大问题的话，可能会是什么？”主要目的是在发布之前思考可能会出现失误的节点，如果是大 风险，做一些必要的防护措施；如果是小风险，心里要清楚自己在冒这个险，准备好一旦出问题该如何补救。另外，由于Facebook发布的产品比较多，经常 出现互相影响的情况，做发布前评估可以让大家知道什么产品即将在什么时候推出去。&lt;/p&gt;
&lt;p&gt;一种发布工程的做法是阀门控制式的灰度发布，就是有所控制地选择发布的人群及其比例。灰度发布是控制发布的范围和速度，但如何才能得知某一阶段产品发布的质量，何种状况下才提高灰度发布的范围呢？只有通过数据监测来判断发布状态。需要监测两类数据。&lt;/p&gt;
&lt;p&gt;一类数据反映当前的系统状态，比如访问总量、访问成功量及其占总量的比例、致命范围错误的量和比例、访问速度、出现最多的错误类型统计等。这些数据的统计和展示都应该是实时的，才能确保一旦发生问题，能够在最短的时间内发现并采取措施。&lt;/p&gt;
&lt;p&gt;另一类数据反映新功能的用户影响（User Impact或者Business Insight）。这部分数据能直接反映出一开始做这个产品或者功能的目的。只有这部分的数据反馈是正向的，而且其变化达到了让人接受的程度，才可以考虑扩大发布范围。&lt;/p&gt;
&lt;p&gt;并不是所有的发布都是成功的。从我的经验来看，追求完美的发布是不现实的，不管之前的Pre-launch Review多么全面，每次发布都有这样或者那样的问题产生，最好的情况就是每次的问题都是新的，而不是上次已经出现的失误。但在问题发生之后，通常通过 Post-Mortem尝试尽可能从失误中吸取教训，让每次的发布带来的学习价值最大化。&lt;/p&gt;
&lt;p&gt;所谓Post-mortem，是通过分析过去发生的问题，从中总结可以采取的行动方案，以避免类似的错误再次发生。不仅适合于产品发布产生的问题研究，同时也常用于任何突发事件的事后分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上就是我所总结的Facebook产品开发流程，当然，对于每一个具体的产品来说，不一定严格按照这些步骤进行，但大体的思路类似。根据需要，部分步骤可以被省略。根本目的是为了在产品满足基本的质量标准之后，尽可能早地发布出去，然后根据监测数据再快速迭代。&lt;/p&gt;
&lt;p&gt;我跟国内的一些创业公司就产品开发流程进行过沟通，希望硅谷公司的思路可以带给他们启发。然而，Facebook的这些做法不一定适用于中国的互联网企业。 在Facebook，很多时候是在证明你不行之前，假设你有能力完成一件艰巨的任务。由于Facebook招的人都是最顶尖的，这种假设在多数情况下被证明是可行的。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignright size-full wp-image-15591&quot; style=&quot;border: 1px solid black;&quot; title=&quot;封面&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/512ac833aca321.jpg&quot; alt=&quot;&quot; width=&quot;123&quot; height=&quot;155&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;本文节选自印刷工业出版社《打造Facebook：亲历Facebook爆发的5年》一书。特此感谢作者王淮的授权。本文选登时有删减。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.programmer.com.cn/15074/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;本文选自《程序员》杂志2013年3期，未经允许不得转载。如需转载请联系 market@csdn.net&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dingyue.programmer.com.cn/&quot; target=&quot;_blank&quot;&gt;《程序员》2013年杂志订阅送好礼活动火热进行中&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/723865970/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15584/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15584/feed/</wfw:commentRss><slash:comments>1</slash:comments><description>文/王淮 王淮是Facebook第二位中国籍工程师，也是第一位中国籍研发经理，他一手开创了Facebook的支付安全和客服工具领域。2011年他离开Facebook，回国成为天使投资人，希望用自己在Facebook的经验帮助创业者。王淮下周将做客CSDN，欢迎读者朋友留言，我们将挑选部分问题，在专访中邀请王淮解答。 在详细说明Facebook产品开发流程的九大步骤之前，必须先讲清楚一点，这些是我用马后炮的方式来思考自己在Facebook做产 品、项目的实践中可能出现的步骤。所谓的“流程”，在Facebook内部并不存在，这些步骤并不都是必须的。对于不同类型的项目，有些对时间要求高一些，所以更强调速度；有些对质量要求高一些，会更强调项目管理的流程（Process）。请读者在阅读时仔细斟酌，哪些符合自身的实际情况，则可以借鉴； 哪些不适合，要灵活掌握。 描绘远景，设置目标 做每件事情之前都要有明确的目标，在聚焦于细节之前要有大的远景（Vision），这可以在以后的实施过程中指引方向。对于远景的思考，主要围绕以下三点。 1. 为什么设这个目标，而不是另外一个？ 2. 在做一件事情之前，脑子里应该有这件事情完成之后是什么样子这个画面，接下来很多事情都是围绕着这个最终画面来进行的。 3. 计划做些什么来实现这个远景？这就需要将最终目标具体化，变成一个可以想象的图片，甚至量化，然后才能使得最终目标容易被别人理解。 那又该如何设定目标呢？在Facebook，常用的方法是遵循“SMART”规则。 S——非常详细具体的（Specific）。目标必须被清晰定义，无法被混淆或者误解。 M——是能够衡量的（Measurable）。只有可以被衡量的目标，才能一直清楚做得如何，离目标有多远，当前是超出还是低于预期的进度。 A——要有足够的难度和挑战性（Aggressive）。容易完成的目标，很容易让员工懈怠；一旦失去战斗的激情，更谈不上发挥潜能。 R——现实的（Realistic），这是对上一点的平衡。过于有难度的目标，会令员工疲惫不堪，如果最后还是没能完成任务的话，对他们的信心是非常大的打击。 T——要有实现的期限（Time-bound）。没有实现期限的目标是没有意义的，因为不知道什么时候应该到达什么程度。 有了目标之后，才可能有很详细的项目计划，所有的项目都应该是跟这些目标相关的。不相干的项目会分散注意力（Distraction），要坚决抵制。接下来，组里人员的绝大多数时间都要花在跟这几个目标相关的项目上。 收集想法并排出优先次序 有 了目标以后，会产生很多相关的想法（Idea），但很难判断究竟哪个想法一定能达到这些目标，也不可能把所有的想法都试一遍，往往到最后都需要有理有据地 进行“赌博”，把精力押在某几个核心的想法上。这也是Facebook要招最好的工程师的原因之一。工程师不仅要善于写程序，也要有选择想法的能力，你不 仅要对这个问题有很深入的思考，进行大量的分析，还要有胆量，能果断押注，并且有很高的命中率。 那么，这些想法从何而来呢？最自然的方式就 是之前延续下来的、大家明确知道要做的项目，而那些不明确的想法，才是难点。在发展非常快的公司里，绝对不会缺少这种不明确的想法。在Facebook， 一般是由技术经理、产品经理、工程师贡献大量的想法。负责商业运营（Business Operation）的同事也会贡献一些想法。做下一个月计划时，我会在当月25日左右开始给相关人员发一个一周后的头脑风暴会议邀请，并希望他们在会议 之前把自己认为应做的或者想做的事情发邮件告诉我。我事先做分类整理，让会议进行得更加高效。当然，线下的讨论、分享等也是产生想法的好机会。 接下来最为关键的就是分析想法——如何挑选出最可能产生效果的想法。理论上，如果有无限的资源，我们应该尝试所有的想法。但在Facebook，任何时候都处于资源短缺的状态，我们必须把有限的资源放到有可能产生最大价值的想法上面。 这里，我要特别强调一下“Top X（只做前X项）”规则：只做对目标最有影响的前X项。我们会对所有的想法进行讨论，根据每个想法对目标的影响和其所需要的资源（主要是人力与时间—— “人周”）进行讨论，然后排序（按P0，P1，P2……的方式来），最后挑选排在最前面的几项。分析完后，对几个明显一定要做的想法很容易决定，对几个要 去掉的也很容易决定，关键是剩下的那些想法，没有足够的精力把它们都尝试一遍，这就要考验你的抉择能力了。 跨团队沟通 决定了要做的项目之后，就需讨论如何跟其他相关组的计划对接。你当然不希望原本以为兄弟组能配合自己做一个项目时，却发现对方并未把与你项目相关的工作放入他们的计划中。这里要进行的沟通，就是让相关组之间做的事情是相辅相成的，而不是互相扯皮，造成不必要的内耗。 有两类人是特别需要沟通的。 1. 不同职能之间的沟通，包括工程师、产品经理、设计师，还有与项目相关的上下游团队或部门。 2. 相关的工程兄弟组之间的沟通。因为大家相互之间经常有技术或者框架上的共享，我们定下要做的事情，就看看相互之间是否有可以匹配的项目，如果我们需要他们的配合，就要看怎样可以列入他们的计划。 告知所有可能关心的人 我们会召开一次最终的计划定夺会议。主要是由工程师和产品经理及一些非常相关的人参加，这种会议是小规模的，因为不想在决策时让其他非产品技术的人员参与进 来，其他人的声音已经在之前的跨团队沟通过程中被充分地考虑了。如果前面的工作准备得比较好，这种会议速度都很快，一般半个小时左右。 整个计划定下来之后，会发一封邮件给所有关心该计划的人和相关工作的人。并且会在接收人那里把老板、老板的老板都放进去，以确保他们能清楚、理解并支持我们组的计划。 设计产品 对于任何一个项目，具体执行中一般都涉及四个维度：功能（Feature Set），预期完成时间（Time to Market），预算（Budget，主要是人员，还有服务器、带宽资源、金钱等），完成质量（Quality，包括可扩展性Scalability、性 能Performance等）。不管你做没做计划，所有的决定都围绕着这四个方面进行考量。如果进度拖后了，那么可以去掉或精简一个功能，或者推后完成的 时间，或者增加人手、加大投入，或者降低质量等，无非就是在这四个方面进行取舍。 很重要的一点是，设计产品时，要大概知道第一版本（V1）是什么样子。可以在设计时构思产品的最终状态，但公司不会允许花大量的资源去打造一个所谓的终极版本。一定要思考第一版本包含哪些功能、什么时间发布、要多少人员配置、要花多少钱做市场宣传、达到什么效果等。 这可以避免一开始投入过大，但做出的产品并不是市场所需要的，再进行很大修改甚至放弃该产品的情况出现，这无疑是很大的浪费。 [...]&lt;img src=&quot;http://www1.feedsky.com/t1/723865970/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15584/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>管理</category><category>高端视点</category><category>facebook</category><pubDate>Fri, 15 Mar 2013 13:55:44 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15584/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15584</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15584/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/723865970/6222641</fs:itemid></item><item><title>程序员的年度计划</title><link>http://www.programmer.com.cn/15065/</link><content:encoded>&lt;p&gt;&lt;strong&gt;对程序员来说，挑战自己很重要，没人甘心在创意或技术上停滞不前。犹他大学计算机教授Matt Might分享了他的年度计划（&lt;a href=&quot;http://matt.might.net/articles/programmers-resolutions/&quot; target=&quot;_blank&quot;&gt;http://matt.might.net/articles/programmers-resolutions/&lt;/a&gt;），引发了很多人的共鸣。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 感受线下生活&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你感觉生活被网络束缚，所得渐渐变少时，请尝试对线下生活（例如烹饪、天文和木工）多投入一些精力，可能有意想不到的收获。&lt;span id=&quot;more-15065&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 保持健康&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序员时常久坐，这让我们容易受到一些特有的健康问题困扰，却又往往视而不见。用一个月时间养成一项健身习惯，也别忽视身体的警告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 拥抱不适&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我二十出头时，曾经研究年长者为何有人不断进步，有人停滞不前？答案是“舒适”。我们习惯找到一个适合自己的系统就不再改变，但技术不是这样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 学门新编程语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只会一门编程语言将限制自己解决问题的范围，职业生涯也会少了一些选择。用一个月时间学一门新语言（如Racket、Haskell、OCaml）或新的编程范式吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 自动化&lt;/strong&gt;&lt;br /&gt;
程序员身上最没有充分发挥的潜力是像在虚拟世界那样，让真实世界也实现自动化。试着用一个月的时间研究下机器人、Arduino，以及类似Insteon的系统是件有意思的事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 学习数学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机科学的核心是数学法则，更好的数学技有助于成为更优秀的程序员。尝试系统学习一下逻辑、离散数学和统计学。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 关注安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很少有程序员养成了良好的安全习惯，试着用密码管理器保存和生成密码，研究一年中影响最大的安全事故是怎样发生的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 备份数据&lt;/strong&gt;&lt;br /&gt;
每年都用一段时间检验你的备份策略，研究如何让这套系统成本更低，使用更便捷。对于关键文件要使用版本管理系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. 学习新软件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;为自己开发的软件增加创意的一个方式是，学习其他新软件。如果你没尝试过3D建模，那么可以学Blender；若你不会LaTeX，很值得尝试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10. 完成一个个人项目&lt;/strong&gt;&lt;br /&gt;
倘若你一直在为别人开发软件，那何不为自己也写一个呢？花一个月的时间完成它，然后把它开源。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.programmer.com.cn/15074/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;本文选自《程序员》杂志2013年3期，未经允许不得转载。如需转载请联系 market@csdn.net&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dingyue.programmer.com.cn/&quot; target=&quot;_blank&quot;&gt;《程序员》2013年杂志订阅送好礼活动火热进行中&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/723865971/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15065/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15065/feed/</wfw:commentRss><slash:comments>3</slash:comments><description>对程序员来说，挑战自己很重要，没人甘心在创意或技术上停滞不前。犹他大学计算机教授Matt Might分享了他的年度计划（http://matt.might.net/articles/programmers-resolutions/），引发了很多人的共鸣。 1. 感受线下生活 当你感觉生活被网络束缚，所得渐渐变少时，请尝试对线下生活（例如烹饪、天文和木工）多投入一些精力，可能有意想不到的收获。 2. 保持健康 程序员时常久坐，这让我们容易受到一些特有的健康问题困扰，却又往往视而不见。用一个月时间养成一项健身习惯，也别忽视身体的警告。 3. 拥抱不适 在我二十出头时，曾经研究年长者为何有人不断进步，有人停滞不前？答案是“舒适”。我们习惯找到一个适合自己的系统就不再改变，但技术不是这样。 4. 学门新编程语言 只会一门编程语言将限制自己解决问题的范围，职业生涯也会少了一些选择。用一个月时间学一门新语言（如Racket、Haskell、OCaml）或新的编程范式吧。 5. 自动化 程序员身上最没有充分发挥的潜力是像在虚拟世界那样，让真实世界也实现自动化。试着用一个月的时间研究下机器人、Arduino，以及类似Insteon的系统是件有意思的事。 6. 学习数学 计算机科学的核心是数学法则，更好的数学技有助于成为更优秀的程序员。尝试系统学习一下逻辑、离散数学和统计学。 7. 关注安全 很少有程序员养成了良好的安全习惯，试着用密码管理器保存和生成密码，研究一年中影响最大的安全事故是怎样发生的。 8. 备份数据 每年都用一段时间检验你的备份策略，研究如何让这套系统成本更低，使用更便捷。对于关键文件要使用版本管理系统。 9. 学习新软件 为自己开发的软件增加创意的一个方式是，学习其他新软件。如果你没尝试过3D建模，那么可以学Blender；若你不会LaTeX，很值得尝试。 10. 完成一个个人项目 倘若你一直在为别人开发软件，那何不为自己也写一个呢？花一个月的时间完成它，然后把它开源。 本文选自《程序员》杂志2013年3期，未经允许不得转载。如需转载请联系 market@csdn.net 《程序员》2013年杂志订阅送好礼活动火热进行中&lt;img src=&quot;http://www1.feedsky.com/t1/723865971/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15065/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>每日关注</category><category>热点报道</category><category>程序员</category><pubDate>Wed, 13 Mar 2013 22:30:33 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15065/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15065</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15065/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/723865971/6222641</fs:itemid></item><item><title>开源前端框架纵横谈</title><link>http://www.programmer.com.cn/15552/</link><content:encoded>&lt;div&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;文 / 尤雨溪&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;近年来随着Web应用交互复杂度的提升，前端开发也迎来了一个高速发展的时期。除了一些老牌框架纷纷推出改动较大的升级之外，还涌现出一批新生代的开源库和框架，推动着Web应用开发理念向越来越强调前端架构的方向发展。当下的前端技术可以说是处在一个新旧交替的过程之中，同时存在着许多不同的观念和实践。&lt;span id=&quot;more-15552&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文试图对目前数量繁多的前端框架进行一些较笼统的分析和比较，抛砖引玉，希望能为大家在选择前端的技术架构时提供一些有益的参考。需要明确的是，本文探讨的前端架构是以JavaScript为主。有一些主要关注CSS层面的前端框架，如Bootstrap，不在本文的讨论范围之内。&lt;/p&gt;
&lt;p&gt;今天的JavaScript框架和库繁多复杂，很大程度上源于Web前端开发本身的特殊性。从当初的可有可无到今天各种功能完备的HTML5标 准，JavaScript在Web应用中的职责和定位经历了巨大的变化。加上长期以来各种浏览器对ECMA标准支持参差不齐的复杂环境，这导致大家对于 JavaScript能做什么、该做什么、应该怎么做一直无法形成共识。一个Web应用可以把所有业务逻辑全部放在服务器端，几乎不依赖 JavaScript；也可以完全用JavaScript构建客户端，服务器只负责数据接口；更有可能选择介于两者之间的折中方案。整体架构选择的多样性 使得不同的应用对于前端架构有着截然不同的需求。这意味着很难有一个前端库或框架可以满足所有人，也使得开发者在找不到完美方案的情况下选择重复造轮子。 同时，由于JavaScript是一门相当灵活的语言，不同背景的开发者借鉴了许多不同的软件设计思想来构建他们理想中的JavaScript框架，这也 导致不同的框架/库在解决同一个问题时经常有不同的方案，例如单页应用的设计模式问题。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;框架vs.库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;众所周知，在前端开发中对于库（Library）和框架（Framework）的区分向来是有些模糊的。像jQuery、YUI这些项目的官方描述都是 “库”，却经常在各种地方被人们称作“框架”。近两年出现的一些MVC项目号称框架，实际上却更像库。此外，在同样号称框架的各个项目之间所覆盖的功能也 都有所不同。传统软件工程对于库和框架的区分主要着眼于对应用运行流程的控制权。框架提供架构，控制运行流程，让开发者在合适的地方书写针对具体问题的代 码；而库则附属于架构，不控制运行流程，只提供可调用的函数。但由于上述Web前端开发的特殊性，这样的定义显得有些过于严格：真正称得上框架的项目很 少，却又经常需要和作为库的项目进行比较。因此，在比较JavaScript开源项目时，是框架还是库并不特别重要，首先应该分析该项目覆盖了前端开发中 的哪些问题（下文为了论述方便，一律用框架指代各类JavaScript开源项目）。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;前端开发可能面对的需求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前端开发中最常见的问题大致可以分为：封装原生API和常用任务、基础架构、富应用架构、视觉交互，以及工具链。下面我们逐个分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装原生API和常用任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript的原生API存在以下问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象、方法名烦琐。&lt;/li&gt;
&lt;li&gt;缺少一些常用任务的语法糖。&lt;/li&gt;
&lt;li&gt;旧浏览器兼容性不佳。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此早期的一些框架最主要的目标就是把烦琐的原生API和常用的任务封装成更简洁直观的API，同时，在封装过程中也处理了兼容性问题。jQuery就是解 决这一部分问题的典型方案。HTML5和ECMAScript 5标准的出台使得这些问题有所好转。随着新标准的普及，将来对于这一部分功能的需求会逐渐减弱。通常来说，封装的对象包含以下类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM的选择和操作：经典的例子如jQuery的链式API。&lt;/li&gt;
&lt;li&gt;DOM事件处理：一个重点是简化事件的delegation，即利用事件冒泡机制在父元素上用一个侦听函数侦听触发在多个子元素上的事件。&lt;/li&gt;
&lt;li&gt;Ajax：简化烦琐的XMLHttpRequest API，并且加强其语义性。&lt;/li&gt;
&lt;li&gt;语言增强：主要提供一些对数组和对象进行操作的便利函数。jQuery包含一些，但更典型的有Underscore和Lodash。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基础架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一部分通常是各类框架中比较底层的功能，决定了采用此框架的代码是如何被组织到一起的。目标是提高代码的可维护性、可协作性和可测试性。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;模块管理&lt;/strong&gt;&lt;/span&gt;：对大型的JavaScript项目来说，模块化开发是必需的。有些框架只提供基本的模块注册机制以防止全局变量污染和冲突，而另一些则提供包括 模块依赖解析、文件加载、压缩打包的功能。目前JavaScript模块管理有两个互相竞争的标准，一个是AMD（Asynchronous Module Definition），采用的框架有Dojo，单独的模块管理库有RequireJS；另一个是CommonJS的模块标准，采用者有模块管理库 SeaJS，以及基于SeaJS的开放型框架Arale。&lt;strong&gt;&lt;span style=&quot;color: #333333;&quot;&gt;面向对象&lt;/span&gt;&lt;/strong&gt;：JavaScript有原型继承，并且可以非常灵活地进行动态混入，但很多大型项目还是需要一个统一的面向对象的继承/扩展系统。对 此，John Resig、Douglas Crockford、Nicholas Zakas等各路JavaScript大神都曾经进行研究并给出过各自的解决方案，许多框架中也包含类似的解决方案。对此感兴趣的同学推荐阅读Arale 文档中的这篇文章：&lt;a href=&quot;http://aralejs.org/class/docs/competitors.html &quot; target=&quot;_blank&quot;&gt;http://aralejs.org/class/docs/competitors.html &lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;自定义事件系统&lt;/strong&gt;&lt;/span&gt;：为了提高模块的可复用性、整个系统的容错性和灵活性，各个模块之间需要尽量解耦，使得相互之间尽可能减少依赖。要实现这样的解耦，一个自定义的事件机制 (通常借鉴Pub-Sub、Observer、Mediator等设计模式) 是很好的手段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #333333;&quot;&gt;组件系统&lt;/span&gt;&lt;/strong&gt;：定义如何使用和书写组件、组件之间如何相互调用和通信等。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;富应用架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这一部分的主要目的是利用设计模式进一步提高代码复用，使得开发者的精力可以主要集中在实现应用本身的功能上。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;代码逻辑分层&lt;/strong&gt;&lt;/span&gt;：把对视觉界面、交互逻辑和数据的处理清晰地分开。就这一点而言，大部分框架借鉴了经典的MVC模式，但传统的MVC在前端并不适合直接套 用，因此各个框架对此的处理都略有不同，有些采用了MVP（Model-View-Presenter）或是MVVM（Model-View- ViewModel）模式。著名前端布道师Addy Osmani有详细的分析，本文受篇幅所限不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;数据绑定：&lt;/strong&gt;&lt;/span&gt;把界面和数据模型进行绑定，使得一方变化的时候另一方也会自动变化，可以省去手动更新DOM的操作。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;数据与服务器端的同步：&lt;/strong&gt;&lt;/span&gt;服务器端提供符合REST规范的API，前端的数据模型可以封装同步操作，可以省去手动发送Ajax请求的过程。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;模板渲染：&lt;/strong&gt;&lt;/span&gt;在前端存储和渲染可复用的HTML模版，这样更新界面时不需要再向服务器发送额外的请求。&lt;/p&gt;
&lt;p&gt;URL路径、应用状态和历史管理：无论是从搜索引擎还是用户体验的角度来看，大型单页应用都应该提供和应用的状态相对应的URL，同时不破坏后退键的功能。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;视觉交互&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;传统型大框架会包含这部分内容，通常是基于自身架构上的扩展，对框架自身有依赖性。但一些新框架则只专注于架构，对扩展部分彻底持开放态度，提倡让开发者自己选择最合适的工具。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;效果和动画：&lt;/strong&gt;&lt;/span&gt;用原生JavaScript实现动画是一个比较烦琐的过程，尤其是当需要精确的时间和缓动（easing）处理时。因此一些框架如jQuery提供一个API简洁的动画引擎，并封装了常见的动画效果。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;UI组件库：&lt;/strong&gt;&lt;/span&gt;这是传统型的大框架的主要卖点之一，大量现成的UI组件以及与框架本身的亲和性，可以大幅提高开发效率。YUI、Dojo是典型代表。在选择时，需要注意的一点是可定制性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #333333;&quot;&gt;数据绘图：&lt;/span&gt;&lt;/strong&gt;这是一类比较特定的需求，但其实现的复杂程度也非常高。ExtJS封装了强大的数据图表功能，除此之外也有专门针对数据可视化的库如D3.js。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt;工具链&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;随着前端项目越来越大，维护和上线的流程也越来越复杂。利用好各类工具实现自动化，可以大幅提高效率。随着Node.js社区的迅猛发展，各类基于JavaScript的命令行工具大量出现，这其中就有许多针对前端开发的优秀项目。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;编译工具：&lt;/strong&gt;&lt;/span&gt;这里的编译严格来说是指js的组合和压缩。通常大型项目都会有多达几百KB的js文件，采用模块化开发的话，文件数量也会非常庞大，进行压缩打 包是必不可少的过程。大型框架如Closure Library、Dojo、YUI都自带编译工具。如果使用了模块管理库，例如RequireJS和SeaJS，也可以使用它们自带的打包工具。其他情况 下则可以自己写build script，也可以借助任务化的编译工具如Grunt.js或者Jake。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;包管理工具：&lt;/strong&gt;&lt;/span&gt;很久以来，前端开发者都需要自己下载、管理各类第三方库。前端的包管理机制的好处是可以更方便地管理第三库的版本和相互之间的依赖。目前国外 比较流行的单纯的前端包管理工具有Twitter的Bower，也有混合了包管理和编译于一体的Ender.js和Volo.js，更有集组件框架、包管理和编译于一体的Component。国内方面，SeaJS提供包管理+编译工具spm。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #333333;&quot;&gt;&lt;strong&gt;单元测试工具：&lt;/strong&gt;&lt;/span&gt;前端也需要单元测试。同样的，传统的大型框架也大多自带单元测试工具。单独的测试框架中比较流行而且简单易用的有QUnit、 Jasmine、Mocha等。此外，还有一些更复杂的前端测试框架，包含了在各类浏览器里的自动化测试，这又可以单独开出一个话题，限于篇幅不再深入， 感兴趣的朋友可以参考：&lt;a href=&quot;http://stackoverflow.com/questions/300855/looking-for-a- better-javascript-unit-test-tool&quot; target=&quot;_blank&quot;&gt;http://stackoverflow.com/questions/300855/looking-for-a- better-javascript-unit-test-tool&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;框架的分类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以下根据风格对一些主流框架进行了粗略的分类，但分类并不是绝对的，只是为了简化比较的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;典型如jQuery、MooTools，国内则有百度的Tangram。这一类框架通常只针对上述需求列表中的“封装原生API”这一块。虽然有插件机制，但通常不提供任何架构方面的帮助，因此现在更多的是和架构类的轻量框架搭配使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;典型如Dojo、YUI、Closure Library、ExtJS等，国内则有阿里的KISSY、网易的NEJ、腾讯的JX等。支付宝玉伯将这一类比喻为“大教堂风格”，一般有这些特点：稳 定，经受过实战的考验；覆盖的问题全面，试图在自身范围内解决尽可能多的问题；代码风格和质量一致，也经常会要求使用者遵循一定的风格规范；文档丰富详 细；更新稳重、缓慢；排他性，一旦选择很难替换；通常带有UI组件库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开放型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就国内外的典型例子来说，国外有由Node.js著名活跃开发者TJ Holowaychuck所牵头的Component（&lt;a href=&quot;https://github.com/component/component&quot; target=&quot;_blank&quot;&gt;https://github.com/component/component&lt;/a&gt;），国内则有阿里的Arale和豆瓣的Oz。&lt;/p&gt;
&lt;p&gt;开放型的框架专注于提供开放的基础架构，即代码组织方式和工具链。它们也提供一部分现成的模块，但使用者可以灵活地书写模块，或是博采众家之长，将第三方的库整合为模块来使用，又被称之为“集市风格”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;灵活，可以适应不同类型的架构需求。&lt;/li&gt;
&lt;li&gt;用不同库解决不同问题，解耦性好。&lt;/li&gt;
&lt;li&gt;社区活跃，更新迅速。&lt;/li&gt;
&lt;li&gt;代码风格质量不一。&lt;/li&gt;
&lt;li&gt;选择和整合第三方库时需要很多精力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;单页应用型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代表性的如Backbone.js、Ember.js、AngularJS、Knockout.js等。单页应用的优势是服务器请求数少、UI反应快速、用户体验流畅。对于交互复杂的大型应用，尤其需要有一个为单页应用量身打造的前端架构来支撑。&lt;/p&gt;
&lt;p&gt;这一类框架在近两年大量涌现，如上文所说，存在着许多不同的观点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先是架构采用什么模式：是MVC（Ember.js、AngularJS）、MVP（Backbone.js）还是MVVM（Knockout.js）？&lt;/li&gt;
&lt;li&gt;其次是侵入性：侵入性较强的提供更多的架构支持，但学习曲线也更陡峭一些（Ember.js、AngularJS）；侵入性较弱的则上手更快，和其他框架/库更容易兼容（Backbone.js、Knockout.js）。&lt;/li&gt;
&lt;li&gt;最后是View的处理：是由JavaScript来把基于String的模板渲染成DOM（Ember.js、Backbone.js），还是由JavaScript为已有的DOM添加行为（AngularJS、Knockout.js）？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题目前还没法得出决定性的结论，更多的是看开发者的个人偏好和习惯更适应哪一种。好在这类框架目前社区都相当活跃，因此可以找到不少参考。&lt;/p&gt;
&lt;p&gt;值得一提的是，一些老牌的传统型框架如Dojo、YUI、ExtJS都开始引入了MVC单页应用架构。但Dojo和YUI的这部分功能仍处在比较粗糙的阶段，只有ExtJS进行了整体重大升级，相对成熟一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Twitter在2月初刚开源了它的前端框架Flight。这是一个介于单页应用型和开放型之间的框架。其核心是事件驱动的、基于DOM的组件机制。它强调组件之间相对独立松散的架构，但对组件的写法定义十分严格，具有一定的侵入性和排他性。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;选择框架时应该考虑什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;&lt;strong&gt;项目规模：&lt;/strong&gt;&lt;/span&gt;小项目需要快速迭代，需要灵活性较高、兼容性比较好的架构。而大项目则需要关注成熟度、风格规范、可协作性、可维护性和可测试性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #808080;&quot;&gt;团队的现有资源：&lt;/span&gt;&lt;/strong&gt;团队是否对后台技术选择和架构有一定的偏好？是否已经对某些框架/工具有实战的经验？如果选择一个开放式的框架，是否有足够的精力来整合各类第三方工具？最后，选择一个团队不熟悉的框架，需要衡量带来的好处是否能抵消掉学习成本。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;&lt;strong&gt;产品对用户体验的需求：&lt;/strong&gt;&lt;/span&gt;产品本身更适合做成单页应用还是传统Web应用？产品是需要大量现成的UI组件，还是需要注重每一个细节？&lt;/p&gt;
&lt;p&gt;建议在选择框架时，首先对自己的项目和团队进行定位，然后总结出具体的技术需求列表，最后参照上文列举的各项细节来寻找适合的框架和周边工具。当然，本文无法穷举所有的细节，只能提供大致的选择方向。确定几个潜在选择之后，还需要开发者自己进行深入的研究和试用。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808000;&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前端技术正处在一个新老并存、百家争鸣的时代。一方面我们需要等待HTML5以及其他W3C标准的普及，另一方面更新的标准，如Web Components和ECMAScript 6又已在起草之中。这两个标准普及时，前端架构恐怕又会迎来一次洗牌。但不管怎样，做好足够的功课，然后根据自己的实际需求出发来进行选择总是没错的。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;&lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;作者尤雨溪，就职于Google Creative Lab，参与各类实验性项目的设计与原型开发。GitHub ID：@yyx990803&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.programmer.com.cn/15074/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;本文选自《程序员》杂志2013年3期，未经允许不得转载。如需转载请联系 market@csdn.net&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dingyue.programmer.com.cn/&quot; target=&quot;_blank&quot;&gt;《程序员》2013年杂志订阅送好礼活动火热进行中&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/723865972/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15552/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15552/feed/</wfw:commentRss><slash:comments>1</slash:comments><description>文 / 尤雨溪 近年来随着Web应用交互复杂度的提升，前端开发也迎来了一个高速发展的时期。除了一些老牌框架纷纷推出改动较大的升级之外，还涌现出一批新生代的开源库和框架，推动着Web应用开发理念向越来越强调前端架构的方向发展。当下的前端技术可以说是处在一个新旧交替的过程之中，同时存在着许多不同的观念和实践。 本文试图对目前数量繁多的前端框架进行一些较笼统的分析和比较，抛砖引玉，希望能为大家在选择前端的技术架构时提供一些有益的参考。需要明确的是，本文探讨的前端架构是以JavaScript为主。有一些主要关注CSS层面的前端框架，如Bootstrap，不在本文的讨论范围之内。 今天的JavaScript框架和库繁多复杂，很大程度上源于Web前端开发本身的特殊性。从当初的可有可无到今天各种功能完备的HTML5标 准，JavaScript在Web应用中的职责和定位经历了巨大的变化。加上长期以来各种浏览器对ECMA标准支持参差不齐的复杂环境，这导致大家对于 JavaScript能做什么、该做什么、应该怎么做一直无法形成共识。一个Web应用可以把所有业务逻辑全部放在服务器端，几乎不依赖 JavaScript；也可以完全用JavaScript构建客户端，服务器只负责数据接口；更有可能选择介于两者之间的折中方案。整体架构选择的多样性 使得不同的应用对于前端架构有着截然不同的需求。这意味着很难有一个前端库或框架可以满足所有人，也使得开发者在找不到完美方案的情况下选择重复造轮子。 同时，由于JavaScript是一门相当灵活的语言，不同背景的开发者借鉴了许多不同的软件设计思想来构建他们理想中的JavaScript框架，这也 导致不同的框架/库在解决同一个问题时经常有不同的方案，例如单页应用的设计模式问题。 框架vs.库 众所周知，在前端开发中对于库（Library）和框架（Framework）的区分向来是有些模糊的。像jQuery、YUI这些项目的官方描述都是 “库”，却经常在各种地方被人们称作“框架”。近两年出现的一些MVC项目号称框架，实际上却更像库。此外，在同样号称框架的各个项目之间所覆盖的功能也 都有所不同。传统软件工程对于库和框架的区分主要着眼于对应用运行流程的控制权。框架提供架构，控制运行流程，让开发者在合适的地方书写针对具体问题的代 码；而库则附属于架构，不控制运行流程，只提供可调用的函数。但由于上述Web前端开发的特殊性，这样的定义显得有些过于严格：真正称得上框架的项目很 少，却又经常需要和作为库的项目进行比较。因此，在比较JavaScript开源项目时，是框架还是库并不特别重要，首先应该分析该项目覆盖了前端开发中 的哪些问题（下文为了论述方便，一律用框架指代各类JavaScript开源项目）。 前端开发可能面对的需求 前端开发中最常见的问题大致可以分为：封装原生API和常用任务、基础架构、富应用架构、视觉交互，以及工具链。下面我们逐个分析。 封装原生API和常用任务 JavaScript的原生API存在以下问题。 对象、方法名烦琐。 缺少一些常用任务的语法糖。 旧浏览器兼容性不佳。 因此早期的一些框架最主要的目标就是把烦琐的原生API和常用的任务封装成更简洁直观的API，同时，在封装过程中也处理了兼容性问题。jQuery就是解 决这一部分问题的典型方案。HTML5和ECMAScript 5标准的出台使得这些问题有所好转。随着新标准的普及，将来对于这一部分功能的需求会逐渐减弱。通常来说，封装的对象包含以下类别。 DOM的选择和操作：经典的例子如jQuery的链式API。 DOM事件处理：一个重点是简化事件的delegation，即利用事件冒泡机制在父元素上用一个侦听函数侦听触发在多个子元素上的事件。 Ajax：简化烦琐的XMLHttpRequest API，并且加强其语义性。 语言增强：主要提供一些对数组和对象进行操作的便利函数。jQuery包含一些，但更典型的有Underscore和Lodash。 基础架构 这一部分通常是各类框架中比较底层的功能，决定了采用此框架的代码是如何被组织到一起的。目标是提高代码的可维护性、可协作性和可测试性。 模块管理：对大型的JavaScript项目来说，模块化开发是必需的。有些框架只提供基本的模块注册机制以防止全局变量污染和冲突，而另一些则提供包括 模块依赖解析、文件加载、压缩打包的功能。目前JavaScript模块管理有两个互相竞争的标准，一个是AMD（Asynchronous Module Definition），采用的框架有Dojo，单独的模块管理库有RequireJS；另一个是CommonJS的模块标准，采用者有模块管理库 SeaJS，以及基于SeaJS的开放型框架Arale。面向对象：JavaScript有原型继承，并且可以非常灵活地进行动态混入，但很多大型项目还是需要一个统一的面向对象的继承/扩展系统。对 此，John Resig、Douglas Crockford、Nicholas Zakas等各路JavaScript大神都曾经进行研究并给出过各自的解决方案，许多框架中也包含类似的解决方案。对此感兴趣的同学推荐阅读Arale 文档中的这篇文章：http://aralejs.org/class/docs/competitors.html 。 自定义事件系统：为了提高模块的可复用性、整个系统的容错性和灵活性，各个模块之间需要尽量解耦，使得相互之间尽可能减少依赖。要实现这样的解耦，一个自定义的事件机制 (通常借鉴Pub-Sub、Observer、Mediator等设计模式) 是很好的手段。 组件系统：定义如何使用和书写组件、组件之间如何相互调用和通信等。 富应用架构 这一部分的主要目的是利用设计模式进一步提高代码复用，使得开发者的精力可以主要集中在实现应用本身的功能上。 代码逻辑分层：把对视觉界面、交互逻辑和数据的处理清晰地分开。就这一点而言，大部分框架借鉴了经典的MVC模式，但传统的MVC在前端并不适合直接套 用，因此各个框架对此的处理都略有不同，有些采用了MVP（Model-View-Presenter）或是MVVM（Model-View- [...]&lt;img src=&quot;http://www1.feedsky.com/t1/723865972/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15552/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>热点报道</category><category>前端</category><pubDate>Wed, 13 Mar 2013 22:25:20 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15552/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15552</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15552/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/723865972/6222641</fs:itemid></item><item><title>OSGi使用四问</title><link>http://www.programmer.com.cn/15563/</link><content:encoded>&lt;div&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;文&lt;span style=&quot;font-family: Calibri;&quot;&gt;/&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;周志明、谢小明&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;没有什么技术是万能的，任何一门技术都有它的适用场景和最佳实践方法。&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;不只是一门技术，更多的是一种做系统架构的工具和方法论，如果在不适用的场景中使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，或者在适用的场景中不恰当地使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，都会使整个系统产生架构级的缺陷。因此，了解什么时候该用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是与学会如何使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;同样重要的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;&lt;img class=&quot;aligncenter  wp-image-15573&quot; style=&quot;border: 1px solid black;&quot; title=&quot;封面&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/深入理解OSGi：Equinox原理、应用与最佳实践.jpg&quot; alt=&quot;&quot; width=&quot;180&quot; height=&quot;228&quot; /&gt;&lt;span id=&quot;more-15563&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每个系统遇到的业务环境都是不一样的，笔者不希望以经验式的陈述去回答“什么时候该用&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;”或 “为什么要使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;”这样的问题，而试图通过以下&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;个问题的讨论和利弊权衡，让读者自己去思考为什么这些场景适用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第&lt;span style=&quot;font-family: Calibri;&quot;&gt;1&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;问：&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;能让软件开发变得更容易吗？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不可否认，&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的入门门槛在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;众多技术中算是比较高的，相对陡峭的学习曲线会为第一次使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;开发系统的开发人员带来额外的复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;OSGi&lt;span style=&quot;font-family: 宋体;&quot;&gt;规范由数十个子规范组成，包含了上千个不同用途的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;API&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;接口。&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;规范显得这样庞杂的主要原因是实现“模块化”本身需要解决的问题就非常多。模块化并不仅仅是把系统拆分成不同的块而已—这是&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JAR&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;包就能做的事情，真正的模块化必须考虑到模块中类的导出、隐藏、依赖、版本管理、生命周期变化和模块间交互等一系列的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;鉴于&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;本身就具有较高的复杂度，“引入&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;就能让软件开发变得更容易”无论如何是说不通的，小型系统使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;可能导致开发成本更高。但是这句话又不是完全错误的，随着系统不断发展，在代码量和开发人员都达到一定规模之后，&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;带来的额外成本就不是主要的关注点了，这时候的主要矛盾是软件规模扩大与复杂度随之膨胀间的矛盾。如下图所示，代码量越大、涉及人员越多的系统，软件复杂度就会越高，两者成正比关系。这个观点从宏观角度看是正确的，具体到某个系统，良好的架构和设计可以有效减缓这个比率。基于&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;架构的效率优势在这时候才能体现出来：模块化推动架构师设计出能在一定范围内自治的代码，可以使开发人员只了解当前模块的知识就能高效编码，也有利于代码出现问题时隔断连锁反应。&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的依赖描述和约束能力，强制开发人员必须遵循架构约束，这些让开发人员“不自由”的限制，在系统规模变大后会成为开发效率的强大推动力。&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15566&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 542px&quot;&gt;&lt;img class=&quot;size-full wp-image-15566&quot; title=&quot;图  OSGi对软件复杂度的影响&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/QQ截图20130313152413.jpg&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;233&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;图 OSGi对软件复杂度的影响&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;可以用一个更具体的场景来论述上面的观点，解析&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;架构如何在开发效率上发挥优势。有经验的架构师会有这样的感受：设计一个具有“自约束能力”的系统架构非常不容易。最常见的情况是设计人员设想得很美好，开发人员在实现时做出来的产品却不是那样。大部分软件公司是通过“开发过程”、“编码规范”、“测试驱动”，甚至“人员熟练度”来保证开发人员实现的代码符合设计人员的意图。这样即使在开发阶段做到符合设计需求，也很难保证日后维护人员能够继续贯彻原有的设计思想；随着开发的时间越来越长，系统最终实现的样子可能和原有的设计产生越来越大的偏差。在软件工程中，将这种现象称为“架构腐化”。架构的“自约束能力”就是指限定不同开发人员在实现功能的时候，实现方式都是一致的，最好只有唯一一条遵循设计意愿的路可走，别的方法无法达到目的。更通俗地说就是，尽可能使程序员不写出烂代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举个最浅显的例子，如果有开发人员在&lt;span style=&quot;font-family: Calibri;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层中使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;DAO&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;直接操作数据库，或者在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;DAL&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层直接从&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;HttpSession&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;对象中取上下文信息，这样的代码也许能逃过测试人员的黑盒测试，但是显然是不符合软件开发基本理论的。前者可能因绕过&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Service&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层中的事务配置而出现数据安全问题；后者限制了这样的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;DAO&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;就只能从&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;访问，无法重用和进行单元测试。如果项目中出现这样的代码，笔者认为首要责任在架构师，因为架构师没有把各层的依赖分清，如果&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层只依赖&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Service&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JAR&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;包，那么程序员就无法访问到&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;DAO&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，如果&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;DAL&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;层没有依赖&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Servlet API&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JAR&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;包，那么程序员就不可能访问&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;HttpSession&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;对象，这就是一种架构缺乏自约束能力的表现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大概没有哪个架构师会犯上面例子那样幼稚的错误。但是，实际情况也远比例子中的复杂，甚至有一些问题是&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;语言本身的缺陷带来的，例如，依赖了一个&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JAR&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;包就意味着能够访问这个&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JAR&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;包中的一切类和资源，因为&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JAR&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;包中的内容没有&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Public&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Private&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Protected&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;之分，无法限制用户能访问什么、不能访问什么。更复杂的情况是在引入了同一个&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JAR&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;包的不同版本时怎么办？如果依赖包需要动态变化怎么办？使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;一个很重要的目的就是弥补&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;中资源精细划分的缺陷，加强架构的自约束能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;起源于精小软件占多数的嵌入式领域，但是在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java SE/EE&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;领域中，对于越庞大的系统，使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;进行模块化拆分就越能发挥出优势。在商业上已经有一些使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;控制软件复杂度增长、延缓架构腐化速度的成功案例，如&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Eclipse Marketplace&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，它已经拥有了上千个插件，插件的开发者来自全球各地，技术水平差异很大，插件实现的功能也各不相同，是&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;让这些插件基本遵循了统一的架构约束，并且一般不会因为某个插件的缺陷影响整个&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Eclipse&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的质量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第&lt;span style=&quot;font-family: Calibri;&quot;&gt;2&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;问：&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;能让系统变得更稳定吗？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者遇到过许多由&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;框架引发的问题，例如，最典型的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;ClassNotFoundException&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;异常、类加载器死锁或者在动态环境下的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OutOfMemoryError&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;问题等，这些都是基于&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;架构开发软件时很常见的。从这一方面看，使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;确实会增加系统不稳定的风险，所以，在开发过程中团队中有一两个深入了解&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的成员是必要的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不过，软件是否稳定不是只看开发阶段可能出现多少异常就能衡量的，软件的“稳定”应是多方面共同作用的结果。除了关注开发阶段是否稳定之外，还要关注是否能积累重用稳定的代码，问题出现时能否隔断连锁反应蔓延，缺陷是否容易修复等。在这些方面，&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;就可以带来相当多的好处，例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;OSGi&lt;span style=&quot;font-family: 宋体;&quot;&gt;会引导程序员开发出可积累可重用的软件。我们无法要求程序刚开发出来就是完全稳定的，但可以在开发过程中尽可能重用已稳定的代码来提升程序质量。大家知道，写日志可以使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Log4j&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，做&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;ORM&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;会引入&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Hibernate&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;中有许多经过长期实践检验的、被证实为稳定的开源项目，这些开源项目的共同特征是都经过良好的设计，能够很方便地在其他项目中使用。相对而言，在自己开发项目时很多人没有注意到要进行可积累的设计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;一种典型现象是项目中出现一些“万能的包”，通常名字会是&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;XXXCommons.jar&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;XXXUtils.jar&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;等，这些包中存放了在项目中被多次调用的代码，但是这样的包不能叫做可重用包。当这些包越来越大、类越来越多、功能越来越强时，与这个项目的耦合就越紧密，一般也就无法用在其他项目中了。在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;环境下，“大杂烩”形式的模块是很难生存的，如果某个模块有非常多的依赖项，那么没有人愿意为了使用其中少量功能去承担这些间接依赖的代价。因此设计者必须把模块设计得粒度合理，精心挑选对外发布的接口和引入的依赖，把每个模块视为一个商业产品来对待，这样才能积累出可重用的模块，也利于提高程序稳定性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基于&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;比较容易实现强鲁棒性的系统。普通汽车坏掉一个轮胎就会抛锚，但是飞机在飞行过程中即使坏了其中一个引擎，一般都还能保持正常飞行。对于软件系统来说，如果某一个模块出了问题，能够不波及其他功能的运作，这也是稳定性的一种体现。大多数系统都做不到在某部分出现问题时隔离缺陷带来的连锁反应。试想一下，在自己做过的项目中把&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Common Logging&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;（或&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;slf4j&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）的包拿掉，系统能只损失日志功能而其他部分正常运作吗？但是对于基于&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;架构开发系统，在设计时自然会考虑到模块自治和动态化，当某部分不可用时如何处理是每时每刻都会考虑的问题，如果软件在开发阶段跟随着&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的设计原则来进行，自然而然会实现强鲁棒性的系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;环境下可以做到动态修复缺陷。许多系统都有停机限制，要求&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;7&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;×&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;24&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;小时运行，对于这类系统，&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的动态化能力在出现问题时就非常有用，可以做到不停机地增加或禁止某项功能、更新某个模块，甚至建立一个统一更新的模块仓库，让系统在不中断运行的情况下做到自动更新升级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前面提出的两个问题可以总结为&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是否能提升开发效率和软件质量。&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;在这两方面的作用与软件设计得是否合理关系非常密切，这时&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;好比一个针对“设计”这个因素的放大杠杆，配合好的设计它会更加稳定、高效，而遇到坏的设计，反而会带来更多问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第&lt;span style=&quot;font-family: Calibri;&quot;&gt;3&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;问：&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;能让系统运行得更快吗？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统引入&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的目的可能有很多种，但一般不包括解决性能问题。如果硬要说&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;对性能有什么好处，大概就是让那些有“系统洁癖”的用户可以组装出为自己定制的系统了。例如&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;GlassFish v3.0&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;服务器是基于&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;架构的，它由&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;200&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;多个模块构成，如果不需要&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;EJB&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;或&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JMS&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;这类功能，就可以把对应的模块移除掉，以获得一个更精简的服务器，节省一些内存。总体上讲，&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;框架对系统性能是有一定损耗的，我们从执行和内存两方面来讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先，&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;虚拟机之上实现的，它没有要求虚拟机的支持，完全通过&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;代码实现模块化，在执行上不可避免地会有一些损耗。例如，&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;类加载的层次比普通&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;应用要深很多，这意味着需要经过更多次的类加载委派才能找到所需的类。在两个互相依赖的模块间发生调用时，可能会由于类加载器互相锁定而产生死锁；要避免死锁的出现，有时候不得不选用有性能损失的串行化的加载策略。在服务层上，动态性（表现为服务可能随时不可用）决定了应用不能缓存服务对象，必须在每次使用前查找，这种对&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;服务注册表的频繁访问也会带来一些开销。使用一些具体的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;服务，例如使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;HTTP Service&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;与直接部署在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Web&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;容器中的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Servlet&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;相比会由于请求的桥接和转发产生一些性能损耗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其次，从内存用量来看，&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;允许不同版本的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Package&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;同时存在，这是个优点，但是客观上会占用更多内存。例如，一个库可能需要 &lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;ASM 3.0&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，而同一应用程序使用的另一个库可能需要&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;ASM 2.0&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，要解决这种问题，通常需要更改代码，而在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;中只需要付出一点&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;方法区的内存即可解决。不过，如果对&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;动态性使用不当，可能会因为不正确持有某个过期模块（被更新或卸载的模块）中一个类的实例，导致该类的类加载器无法被回收，进而导致该类加载器下所有类都无法被&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;GC&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;回收掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;仅从性能角度来说，&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;确实会让系统性能略微下降，但是这完全在可接受范围之内。使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;开发时应该考虑到性能的影响，但不应当将其作为是否采用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;架构的主要决策依据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第&lt;span style=&quot;font-family: Calibri;&quot;&gt;4&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;问：&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;能支撑企业级开发吗？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管关于“&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是否能支撑企业级开发”的讨论结果如何，一个必须正视的事实是&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;对企业级开发的支撑能力正在迅速增强。从&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;2007&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;年&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;联盟建立企业专家组以来，&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的发展方向已经逐渐调整到企业级应用领域。在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;IBM&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Apache&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Eclipse&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;基金会等公司和组织推动下，企业级&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;正在变得越来越成熟。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在企业级&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;出现之前，企业级开发要么是走&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java EE&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的重量级路线，要么是走&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;SSH&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的轻量级路线。企业级&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;被引入后并没有扮演一个“革命者”的角色，没有把&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java EE&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;或&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;SSH&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;中积累的东西推倒重来，&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;更像是在扮演一个“组织者”的角色，把各种企业级技术变为它的模块和服务，使以前的企业级开发技术在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;中依然能够发挥作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;OSGi&lt;span style=&quot;font-family: 宋体;&quot;&gt;企业级规范中定义了&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JDBC&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JPA&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JMX&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JTA&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JNDI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;等各种&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java EE&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;技术以及&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;SCA&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;SDO&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;这些非&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java EE&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;标准的企业级技术在&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;环境中的应用方式，这些容器级的服务都可以映射为&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;容器内部的服务来使用。并且到现在，企业级规范定义的内容已经不仅停留在规范文字中，已经有不少专注于&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;企业级服务实现框架出现（例如&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Apache Aries&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;另一方面，&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Blueprint&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;容器规范统一了&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;大型程序中几乎都会用到的依赖注入（&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;DI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）方式，使基于&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Blueprint&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;模块可以在不同的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;DI&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;框架中无缝迁移。这个规范得到&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Apache&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;SpringSource&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;等组织的大力支持，目前这些组织已经发布了若干个&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Blueprint&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;规范的实现容器（例如&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Apache Geronimo&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Equinox Virgo&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Virgo&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;前身就是&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;SpringSource&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;捐献的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Spring DM 2.0&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;）。在最近两三年时间里，企业级&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;成为&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;社区技术发展的主要方向之一，其发展局面可以说是如火如荼。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不过，我们在使用企业级&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的时候也要意识到它还很年轻，其中很多先进的思想可能是遗留程序根本没有考虑过的，还有不少问题的解决都依赖于设计约束来实现。因此，如果是遗留系统的迁移，或者设计本来就做得不好，那么使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;会遇到不少麻烦。以最常见的数据访问为例，如果以前遗留系统使用了&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;ORM&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;方式访问数据库，而迁移到&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;时没有把实体类统一抽取到一个模块，那么&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;ORM&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;模块的依赖就很难配置了，这时不得不使用&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Equinox Buddy&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;甚至&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;DynamicImport-Package&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;这类很不优雅的方式来解决。另一个问题是集群，&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;拥有支持分布式的远程服务规范，而&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的动态性是针对单&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;虚拟机实例而言的，因此要在集群环境下保持&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的动态性，就必须自己做一些工作才行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;作者周志明，资深&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;技术专家，对&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JavaEE&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;企业级应用开发、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;虚拟机和工作流等都有深入的研究，并积累了丰富的经验。著有畅销书《深入理解&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;虚拟机：&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JVM&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;高级特性与最佳实践》。现任远光软件股份有限公司平台开发部经理兼平台架构师，先后参与过国家电网、南方电网等多个国家级大型&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;ERP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;项目的平台架构工作。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;作者谢小明，资深&lt;span style=&quot;font-family: Calibri;&quot;&gt;Java&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;技术专家，具有丰富的&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;JavaEE&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;企业级应用开发开发经验，对&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;OSGi&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Spring&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;、&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;Hibernate&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;等技术和框架有比较深入的研究和认识。现任远光软件股份有限公司平台开发部平台架构师，先后参加与过国家电网、南方电网等多个国家级大型&lt;/span&gt;&lt;span style=&quot;font-family: Calibri;&quot;&gt;ERP&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;项目的平台架构工作。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;本文节选自《深入理解OSGi：Equinox原理、应用与最佳实践》，周志明、谢小明著，由机械工业出版社出版。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;&lt;br /&gt;
&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/723865973/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15563/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15563/feed/</wfw:commentRss><slash:comments>0</slash:comments><description>文/周志明、谢小明 没有什么技术是万能的，任何一门技术都有它的适用场景和最佳实践方法。OSGi不只是一门技术，更多的是一种做系统架构的工具和方法论，如果在不适用的场景中使用OSGi，或者在适用的场景中不恰当地使用OSGi，都会使整个系统产生架构级的缺陷。因此，了解什么时候该用OSGi是与学会如何使用OSGi同样重要的事情。 每个系统遇到的业务环境都是不一样的，笔者不希望以经验式的陈述去回答“什么时候该用OSGi”或 “为什么要使用OSGi”这样的问题，而试图通过以下4个问题的讨论和利弊权衡，让读者自己去思考为什么这些场景适用OSGi。 第1问：OSGi能让软件开发变得更容易吗？ 不可否认，OSGi的入门门槛在Java众多技术中算是比较高的，相对陡峭的学习曲线会为第一次使用OSGi开发系统的开发人员带来额外的复杂度。 OSGi规范由数十个子规范组成，包含了上千个不同用途的API接口。OSGi规范显得这样庞杂的主要原因是实现“模块化”本身需要解决的问题就非常多。模块化并不仅仅是把系统拆分成不同的块而已—这是JAR包就能做的事情，真正的模块化必须考虑到模块中类的导出、隐藏、依赖、版本管理、生命周期变化和模块间交互等一系列的问题。 鉴于OSGi本身就具有较高的复杂度，“引入OSGi就能让软件开发变得更容易”无论如何是说不通的，小型系统使用OSGi可能导致开发成本更高。但是这句话又不是完全错误的，随着系统不断发展，在代码量和开发人员都达到一定规模之后，OSGi带来的额外成本就不是主要的关注点了，这时候的主要矛盾是软件规模扩大与复杂度随之膨胀间的矛盾。如下图所示，代码量越大、涉及人员越多的系统，软件复杂度就会越高，两者成正比关系。这个观点从宏观角度看是正确的，具体到某个系统，良好的架构和设计可以有效减缓这个比率。基于OSGi架构的效率优势在这时候才能体现出来：模块化推动架构师设计出能在一定范围内自治的代码，可以使开发人员只了解当前模块的知识就能高效编码，也有利于代码出现问题时隔断连锁反应。OSGi的依赖描述和约束能力，强制开发人员必须遵循架构约束，这些让开发人员“不自由”的限制，在系统规模变大后会成为开发效率的强大推动力。 可以用一个更具体的场景来论述上面的观点，解析OSGi架构如何在开发效率上发挥优势。有经验的架构师会有这样的感受：设计一个具有“自约束能力”的系统架构非常不容易。最常见的情况是设计人员设想得很美好，开发人员在实现时做出来的产品却不是那样。大部分软件公司是通过“开发过程”、“编码规范”、“测试驱动”，甚至“人员熟练度”来保证开发人员实现的代码符合设计人员的意图。这样即使在开发阶段做到符合设计需求，也很难保证日后维护人员能够继续贯彻原有的设计思想；随着开发的时间越来越长，系统最终实现的样子可能和原有的设计产生越来越大的偏差。在软件工程中，将这种现象称为“架构腐化”。架构的“自约束能力”就是指限定不同开发人员在实现功能的时候，实现方式都是一致的，最好只有唯一一条遵循设计意愿的路可走，别的方法无法达到目的。更通俗地说就是，尽可能使程序员不写出烂代码。 举个最浅显的例子，如果有开发人员在Web层中使用DAO直接操作数据库，或者在DAL层直接从HttpSession对象中取上下文信息，这样的代码也许能逃过测试人员的黑盒测试，但是显然是不符合软件开发基本理论的。前者可能因绕过Service层中的事务配置而出现数据安全问题；后者限制了这样的DAO就只能从Web访问，无法重用和进行单元测试。如果项目中出现这样的代码，笔者认为首要责任在架构师，因为架构师没有把各层的依赖分清，如果Web层只依赖Service层的JAR包，那么程序员就无法访问到DAO，如果DAL层没有依赖Servlet API的JAR包，那么程序员就不可能访问HttpSession对象，这就是一种架构缺乏自约束能力的表现。 大概没有哪个架构师会犯上面例子那样幼稚的错误。但是，实际情况也远比例子中的复杂，甚至有一些问题是Java语言本身的缺陷带来的，例如，依赖了一个JAR包就意味着能够访问这个JAR包中的一切类和资源，因为JAR包中的内容没有Public、Private和Protected之分，无法限制用户能访问什么、不能访问什么。更复杂的情况是在引入了同一个JAR包的不同版本时怎么办？如果依赖包需要动态变化怎么办？使用OSGi一个很重要的目的就是弥补Java中资源精细划分的缺陷，加强架构的自约束能力。 虽然OSGi起源于精小软件占多数的嵌入式领域，但是在Java SE/EE领域中，对于越庞大的系统，使用OSGi进行模块化拆分就越能发挥出优势。在商业上已经有一些使用OSGi控制软件复杂度增长、延缓架构腐化速度的成功案例，如Eclipse Marketplace，它已经拥有了上千个插件，插件的开发者来自全球各地，技术水平差异很大，插件实现的功能也各不相同，是OSGi让这些插件基本遵循了统一的架构约束，并且一般不会因为某个插件的缺陷影响整个Eclipse的质量。 第2问：OSGi能让系统变得更稳定吗？ 笔者遇到过许多由OSGi框架引发的问题，例如，最典型的ClassNotFoundException异常、类加载器死锁或者在动态环境下的OutOfMemoryError问题等，这些都是基于OSGi架构开发软件时很常见的。从这一方面看，使用OSGi确实会增加系统不稳定的风险，所以，在开发过程中团队中有一两个深入了解OSGi的成员是必要的。 不过，软件是否稳定不是只看开发阶段可能出现多少异常就能衡量的，软件的“稳定”应是多方面共同作用的结果。除了关注开发阶段是否稳定之外，还要关注是否能积累重用稳定的代码，问题出现时能否隔断连锁反应蔓延，缺陷是否容易修复等。在这些方面，OSGi就可以带来相当多的好处，例如： OSGi会引导程序员开发出可积累可重用的软件。我们无法要求程序刚开发出来就是完全稳定的，但可以在开发过程中尽可能重用已稳定的代码来提升程序质量。大家知道，写日志可以使用Log4j，做ORM会引入Hibernate，Java中有许多经过长期实践检验的、被证实为稳定的开源项目，这些开源项目的共同特征是都经过良好的设计，能够很方便地在其他项目中使用。相对而言，在自己开发项目时很多人没有注意到要进行可积累的设计。 一种典型现象是项目中出现一些“万能的包”，通常名字会是XXXCommons.jar、XXXUtils.jar等，这些包中存放了在项目中被多次调用的代码，但是这样的包不能叫做可重用包。当这些包越来越大、类越来越多、功能越来越强时，与这个项目的耦合就越紧密，一般也就无法用在其他项目中了。在OSGi环境下，“大杂烩”形式的模块是很难生存的，如果某个模块有非常多的依赖项，那么没有人愿意为了使用其中少量功能去承担这些间接依赖的代价。因此设计者必须把模块设计得粒度合理，精心挑选对外发布的接口和引入的依赖，把每个模块视为一个商业产品来对待，这样才能积累出可重用的模块，也利于提高程序稳定性。 基于OSGi比较容易实现强鲁棒性的系统。普通汽车坏掉一个轮胎就会抛锚，但是飞机在飞行过程中即使坏了其中一个引擎，一般都还能保持正常飞行。对于软件系统来说，如果某一个模块出了问题，能够不波及其他功能的运作，这也是稳定性的一种体现。大多数系统都做不到在某部分出现问题时隔离缺陷带来的连锁反应。试想一下，在自己做过的项目中把Common Logging（或slf4j）的包拿掉，系统能只损失日志功能而其他部分正常运作吗？但是对于基于OSGi架构开发系统，在设计时自然会考虑到模块自治和动态化，当某部分不可用时如何处理是每时每刻都会考虑的问题，如果软件在开发阶段跟随着OSGi的设计原则来进行，自然而然会实现强鲁棒性的系统。 在OSGi环境下可以做到动态修复缺陷。许多系统都有停机限制，要求7×24小时运行，对于这类系统，OSGi的动态化能力在出现问题时就非常有用，可以做到不停机地增加或禁止某项功能、更新某个模块，甚至建立一个统一更新的模块仓库，让系统在不中断运行的情况下做到自动更新升级。 前面提出的两个问题可以总结为OSGi是否能提升开发效率和软件质量。OSGi在这两方面的作用与软件设计得是否合理关系非常密切，这时OSGi好比一个针对“设计”这个因素的放大杠杆，配合好的设计它会更加稳定、高效，而遇到坏的设计，反而会带来更多问题。 第3问：OSGi能让系统运行得更快吗？ 系统引入OSGi的目的可能有很多种，但一般不包括解决性能问题。如果硬要说OSGi对性能有什么好处，大概就是让那些有“系统洁癖”的用户可以组装出为自己定制的系统了。例如GlassFish v3.0服务器是基于OSGi架构的，它由200多个模块构成，如果不需要EJB或JMS这类功能，就可以把对应的模块移除掉，以获得一个更精简的服务器，节省一些内存。总体上讲，OSGi框架对系统性能是有一定损耗的，我们从执行和内存两方面来讨论。 首先，OSGi是在Java虚拟机之上实现的，它没有要求虚拟机的支持，完全通过Java代码实现模块化，在执行上不可避免地会有一些损耗。例如，OSGi类加载的层次比普通Java应用要深很多，这意味着需要经过更多次的类加载委派才能找到所需的类。在两个互相依赖的模块间发生调用时，可能会由于类加载器互相锁定而产生死锁；要避免死锁的出现，有时候不得不选用有性能损失的串行化的加载策略。在服务层上，动态性（表现为服务可能随时不可用）决定了应用不能缓存服务对象，必须在每次使用前查找，这种对OSGi服务注册表的频繁访问也会带来一些开销。使用一些具体的OSGi服务，例如使用HTTP Service与直接部署在Web容器中的Servlet相比会由于请求的桥接和转发产生一些性能损耗。 其次，从内存用量来看，OSGi允许不同版本的Package同时存在，这是个优点，但是客观上会占用更多内存。例如，一个库可能需要 ASM 3.0，而同一应用程序使用的另一个库可能需要ASM 2.0，要解决这种问题，通常需要更改代码，而在OSGi中只需要付出一点Java方法区的内存即可解决。不过，如果对OSGi动态性使用不当，可能会因为不正确持有某个过期模块（被更新或卸载的模块）中一个类的实例，导致该类的类加载器无法被回收，进而导致该类加载器下所有类都无法被GC回收掉。 仅从性能角度来说，OSGi确实会让系统性能略微下降，但是这完全在可接受范围之内。使用OSGi开发时应该考虑到性能的影响，但不应当将其作为是否采用OSGi架构的主要决策依据。 第4问：OSGi能支撑企业级开发吗？ 不管关于“OSGi是否能支撑企业级开发”的讨论结果如何，一个必须正视的事实是OSGi对企业级开发的支撑能力正在迅速增强。从2007年OSGi联盟建立企业专家组以来，OSGi的发展方向已经逐渐调整到企业级应用领域。在IBM、Apache和Eclipse基金会等公司和组织推动下，企业级OSGi正在变得越来越成熟。 在企业级OSGi出现之前，企业级开发要么是走Java EE的重量级路线，要么是走SSH的轻量级路线。企业级OSGi被引入后并没有扮演一个“革命者”的角色，没有把Java EE或SSH中积累的东西推倒重来，OSGi更像是在扮演一个“组织者”的角色，把各种企业级技术变为它的模块和服务，使以前的企业级开发技术在OSGi中依然能够发挥作用。 OSGi企业级规范中定义了JDBC、JPA、JMX、JTA和JNDI等各种Java EE技术以及SCA、SDO这些非Java EE标准的企业级技术在OSGi环境中的应用方式，这些容器级的服务都可以映射为OSGi容器内部的服务来使用。并且到现在，企业级规范定义的内容已经不仅停留在规范文字中，已经有不少专注于OSGi企业级服务实现框架出现（例如Apache Aries）了。 另一方面，OSGi的Blueprint容器规范统一了Java大型程序中几乎都会用到的依赖注入（DI）方式，使基于Blueprint的OSGi模块可以在不同的DI框架中无缝迁移。这个规范得到Apache、SpringSource等组织的大力支持，目前这些组织已经发布了若干个Blueprint规范的实现容器（例如Apache Geronimo和Equinox Virgo，Virgo前身就是SpringSource捐献的Spring DM 2.0）。在最近两三年时间里，企业级OSGi成为Java社区技术发展的主要方向之一，其发展局面可以说是如火如荼。 不过，我们在使用企业级OSGi的时候也要意识到它还很年轻，其中很多先进的思想可能是遗留程序根本没有考虑过的，还有不少问题的解决都依赖于设计约束来实现。因此，如果是遗留系统的迁移，或者设计本来就做得不好，那么使用OSGi会遇到不少麻烦。以最常见的数据访问为例，如果以前遗留系统使用了ORM方式访问数据库，而迁移到OSGi时没有把实体类统一抽取到一个模块，那么ORM模块的依赖就很难配置了，这时不得不使用Equinox Buddy甚至DynamicImport-Package这类很不优雅的方式来解决。另一个问题是集群，OSGi拥有支持分布式的远程服务规范，而OSGi的动态性是针对单Java虚拟机实例而言的，因此要在集群环境下保持OSGi的动态性，就必须自己做一些工作才行。 作者周志明，资深Java技术专家，对JavaEE企业级应用开发、OSGi、Java虚拟机和工作流等都有深入的研究，并积累了丰富的经验。著有畅销书《深入理解Java虚拟机：JVM高级特性与最佳实践》。现任远光软件股份有限公司平台开发部经理兼平台架构师，先后参与过国家电网、南方电网等多个国家级大型ERP项目的平台架构工作。 作者谢小明，资深Java技术专家，具有丰富的JavaEE企业级应用开发开发经验，对OSGi、Spring、Hibernate等技术和框架有比较深入的研究和认识。现任远光软件股份有限公司平台开发部平台架构师，先后参加与过国家电网、南方电网等多个国家级大型ERP项目的平台架构工作。 本文节选自《深入理解OSGi：Equinox原理、应用与最佳实践》，周志明、谢小明著，由机械工业出版社出版。&lt;img src=&quot;http://www1.feedsky.com/t1/723865973/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15563/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>图书推荐</category><pubDate>Wed, 13 Mar 2013 17:41:23 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15563/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15563</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15563/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/723865973/6222641</fs:itemid></item><item><title>C是什么样的语言</title><link>http://www.programmer.com.cn/15528/</link><content:encoded>&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;文/前桥和弥&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;在Donald C. Gause 和Gerald M. Weinberg 合著的《你的灯亮着吗？》一书中，有这样一节。&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;&lt;img class=&quot;aligncenter  wp-image-15533&quot; style=&quot;border: 1px solid black;&quot; title=&quot;封面&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/QQ截图20130311171822.jpg&quot; alt=&quot;&quot; width=&quot;163&quot; height=&quot;216&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;span id=&quot;more-15528&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;某计算机制造商开发了一种新型打印机。技术小组在如何保证打印精度的问题上非常苦恼，每次进行新的测试时，工程师都不得不花很长的时间测量打印机的输出结果来追求精确性。&lt;br /&gt;
丹（Dan Daring）是这个小组中最年轻但或许是最聪明的工程师。 他发明了一种工具，即每隔8 英寸就在铝条上嵌上小针。使用这个工具，可以很快地找到打印机输出位置的误差。&lt;br /&gt;
这个发明显著地提高了生产效率，丹的上司非常高兴，提议给丹颁发一个公司的特别奖赏。他从车间里拿了这个工具，带回办公室，这样他写报告的时候还可以仔细地研究一下。&lt;br /&gt;
这个上司显然还用不惯这个工具，当他把这个工具放在桌子上 的时候，将针尖朝上了。更不幸的是，当丹的上司的上司友好地坐 到桌角上，打算谈谈给丹颁发奖励时，部门内的所有人都听到了他 痛苦的尖叫声——他的屁股上被扎了两个相距8 英寸的孔。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;C 语言就恰如这个工具。也就是说，它是一门&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了解决眼前问题，由开发现场的人发明的，&lt;/li&gt;
&lt;li&gt;虽然使用方便，&lt;/li&gt;
&lt;li&gt;但看上去不怎么顺眼，&lt;/li&gt;
&lt;li&gt;如果不熟悉的人糊里糊涂地使用了它，难免会带来“悲剧”的语言。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;C 的发展历程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;众所周知，C 原本是为了开发UNIX 操作系统而设计的语言。&lt;/p&gt;
&lt;p&gt;如此说来，好像C 应该比UNIX 更早问世，可惜事实并非如此，最早的 UNIX 是用汇编来写的。因为厌倦了总是苦哈哈地使用汇编语言进行编程，UNIX 的开发者Ken Tompson 开发了一种称为“B”的语言。B 语言是1967 年剑桥大学的Martin Richard 开发的BCPL（Basic CPL）的精简版本。BCPL 的前身是1963 年剑桥大学和伦敦大学共同研究开发的CPL（Combined Programming Lanugage） 语言。&lt;/p&gt;
&lt;p&gt;B 语言不直接生成机器码，而是由编译器生成栈式机（Stack Machine）用 的中间代码，中间代码通过解释器（interpreter）执行（类似Java 和早期的 Pascal）。因此，B 语言的执行效率非常低，结果，在后来的UNIX 开发过程中人们放弃了使用B 语言。&lt;/p&gt;
&lt;p&gt;在这之后的1971 年，Ken Tompson 的同事Dennis Ritchie 对B 语言做了改良，追加了char 数据类型，并且让B 语言可以直接生成PDP-11的机器代码。曾经在很短的时间内，大家将这门语言称为NB（New B）。&lt;/p&gt;
&lt;p&gt;之后，NB 改称为C 语言——这就是C 语言的诞生。后来，主要是为了满足使用UNIX 的程序员的需要，C 语言一边接受来自各方面的建议，一边摸着石头过河般地进行着周而复始的功能扩展。1978 年出版了被称为C 语言宝典的The C Programming Language 一书。此书取了两位作者（Brian Kernighan 和Dennis Ritchie）的姓氏首字母， 简称为K&amp;amp;R。在后面提到的ANSI 标准制定之前，此书一直作为C 语言语法 的参考书被人们广泛使用。听说这本书在最初发行的时候，Prentice-Hall 出版社制订了对于当时存在 的130 个UNIX站点平均每个能卖9 本的销售计划（相比Lift With UNIX[2]）。当然了，哪怕是初版K&amp;amp;R的销售量，也以3 位数的数量级超过了 Prentice-Hall 出版社最初的销售计划 。原本只是像“丹的工具”一样为了满足 自用的C 语言，历经坎坷，最终成为全世界广泛使用的开发语言。&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;顺便提一下，通过&lt;a href=&quot;http://www.cs.bell-labs.com/cm/cs/cbook/index.html&quot; target=&quot;_blank&quot;&gt;http://www.cs.bell-labs.com/cm/cs/cbook/index.html&lt;/a&gt;可以看到K&amp;amp;R 的网页，各语种的K&amp;amp;R 封面排列在一起，颇为壮观。&lt;img class=&quot;aligncenter  wp-image-15530&quot; title=&quot;封面&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/QQ截图20130311170333.jpg&quot; alt=&quot;&quot; width=&quot;564&quot; height=&quot;396&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么存在奇怪的指针运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果试图访问数组的内容，老老实实地使用下标就可以了。为什么存在指针运算这样奇怪的功能呢？&lt;/p&gt;
&lt;p&gt;其中的一个原因就是受到了C的祖先B语言的影响。&lt;/p&gt;
&lt;p&gt;B是一种“没有类型”的语言。B中可以使用的类型只有word 型（也就是整型），指针也是作为整型来使用的（像浮点型这样高级的事物，你根本见不到）。B 是虚拟机上运行的解释器，这个虚拟机以word 为单位分配内存地址（如今普通的计算机以字节为单位）。由于B以word 为单位，如果指针（仅仅是表现地址的简单的整数）加1，指针就指向数组的下一个元素。为了继承这种特性，C引入了“指针加1，指针前进它所指向类型的长度”这个规则。B 语言中同样存在p[i]是 (p + i)的语法糖这样的规则。可是，这里的(p + i)只不过是单纯的整数之间的加法运算。解引用*、地址运算符&amp;amp;，也以几乎和C相同的形态存在于B语言中。另外还有一个理由就是，早先使用指针运算可以写出高效的程序。通常情况下，我们总是使用循环语句来处理数组，一般都写成下面的形式，&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;for (i = 0; i &amp;lt; LOOP_MAX; i++) {&lt;br /&gt;
/*&lt;br /&gt;
* 在这里，使用array[i]进行各种各样的处理。&lt;br /&gt;
* array[i]会出现多次。&lt;br /&gt;
*/&lt;br /&gt;
}&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;array[i]在循环中会出现多次，每次都要进行相当于 array+i的加法运算，效率自然比较低。&lt;br /&gt;
因此，可以使用指针运算重写上面这段循环，&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;for (p = &amp;amp;array[0]; p != &amp;amp;array[LOOP_MAX]，p++) {&lt;br /&gt;
/*&lt;br /&gt;
* 在这里，使用*p进行各种各样的处理。&lt;br /&gt;
* *p会出现多次。&lt;br /&gt;
*/&lt;br /&gt;
}&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;尽管*p在循环内部会出现多次，但加法运算只有在循环结束的时候执行一次。&lt;/p&gt;
&lt;p&gt;K&amp;amp;R p.119 中叙述了“一般情况下，使用指针的程序比较高效”。上面的说明应该可以作为这段叙述的根据吧。可是，这些无论怎样都是老黄历了。&lt;/p&gt;
&lt;p&gt;如今，编译器在不断地被优化，对于循环内部重复出现的表达式的集中处理，是编译器优化的基本内容。对于现在一般的C 编译器，无论你使用数组还是指针，效率上都不会出现明显的差距。基本上都是输出完全相同的机器码。&lt;/p&gt;
&lt;p&gt;总的来说，C 的指针运算功能的出现，源自于早期的C自身没有优化手段。这一点并不奇怪，请大家回想一下在前面介绍过的内容，C本来只是为了解决开发现场的人们眼前的问题而出现的一种语言。Unix 之前的OS几乎都是使用汇编写的，即使晦涩难懂，人们也不会大惊小怪。对于当时的环境，追求什么编译器优化实在有点勉为其难。因此，当初开发C 语言的时候，是完全有必要提供指针运算功能的。可是……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要滥用指针运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被称为C语言宝典的K&amp;amp;R 指出：“一般情况下，使用指针的程序比较高效。”这完全是“那个时代的错误”。&lt;/p&gt;
&lt;p&gt;可是，正如前面所说，对于如今的编译器，无论是使用指针运算还是下标运算，都生成几乎完全相同的执行代码。&lt;/p&gt;
&lt;p&gt;事到如今……难道不应该放弃使用指针运算，老老实实地使用下标访问吗？&lt;/p&gt;
&lt;p&gt;虽然K&amp;amp;R 被很多人奉为“神书”，可是对于我来说，它连作为菜鸟实习的资料也不够格。为什么这么说？因为在此书中，那些滥用指针的例程完全可以让你崩溃。&lt;/p&gt;
&lt;p&gt;莫名其妙地使用像*++args[0]这样的语句，并且乐此不疲，实在让人心烦。&lt;/p&gt;
&lt;p&gt;K&amp;amp;R 里面记载了下面这个作为strcpy()实现的例子：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;/* 将t拷贝成s;指针版3 */&lt;br /&gt;
void strcpy(char *s, char *t)&lt;br /&gt;
{&lt;br /&gt;
while (*s++ = *t++)&lt;br /&gt;
;&lt;br /&gt;
}&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;虽然乍一看不容易理解，但是这种写法其实是非常方便的。因为会在C 程序中经常遇到，所以我们应该掌握这种惯用写法。既然知道“乍一看不容易理解”，那就不应该这样写，难道不是吗？&lt;/p&gt;
&lt;p&gt;满大街的C 语言入门书都在教育我们，使用指针运算比使用下标会让程序&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;☑更有效率&lt;/li&gt;
&lt;li&gt;☑更有C 语言范儿&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓的“更有效率”，只不过是臆想罢了。对于这种“微不足道的”优化工作，与其让人去小心翼翼地做，还不如交给编译器来干。&lt;/p&gt;
&lt;p&gt;所谓“更有C语言范儿”好像是有些道理。如果只是为了要让程序“有范儿”，而让代码变得晦涩难懂，那么还是拜托你行行好，扔掉这种恶习吧。&lt;/p&gt;
&lt;p&gt;在学校里，我们要完成一些课后作业。好不容易完成了一个使用下标的程序题，不料后面的那道题为“请使用指针将刚才那道题的程序重新完成一遍”。这种事常有吧。&lt;/p&gt;
&lt;p&gt;老实说，这种事很无聊。也许你会很“威武”地依然使用下标原封不动&lt;br /&gt;
地把程序又写了一遍，然后交给了老师。面对老师的指责，你义正辞严：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;咦，下标运算符[]只不过是指针运算的语法糖而已，在本质上这样的写法也是在使用指针啊。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;尽管这样，这位可爱的老师可能还是不会放过你，于是你就急了：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;行，不就是把像p[i]这样使用下标的地方，机械地一个个替换成* (p+i)嘛。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;话说回来，丢了学分，我可不负责哟。在C的世界里，使用指针运算要比使用下标的写法让人感觉更“帅一些”。&lt;/p&gt;
&lt;p&gt;但是……与其在这些无聊的地方“耍酷”，倒不如多花点时间学一些有用的知识。你要知道，作为一个程序员，还有堆积如山的知识等着你去掌握呢。&lt;/p&gt;
&lt;p&gt;当然，什么样的规则都有例外，比如，在“一个巨大的char 数组中，参杂了各种类型的数据①，并且我们试图读取第多少字节的数据”这样的情况下，还是使用指针运算写的程序比较容易理解。&lt;/p&gt;
&lt;p&gt;此外，作为一个C程序员连指针运算的代码也读不懂，多少有点可悲。&lt;/p&gt;
&lt;p&gt;尽管如此，让我们至少从现在开始尽量使用下标来写新的程序，这样做对自己，以及对以后有机会阅读你的程序的人，都有好处。&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;作者前桥和弥（Maebasi Kazuya），1969年出生，著有《彻底掌握C语言》、《Java之谜和陷阱》、《自己设计编程语言》等。其一针见血的“毒舌”文风和对编程语言深刻的见地受到广大读者的欢迎。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;本文选自《征服C指针》一书，作者前桥和弥，吴雅明译，由人民邮电出版社出版。&lt;/strong&gt;&lt;/p&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/723865974/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15528/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15528/feed/</wfw:commentRss><slash:comments>6</slash:comments><description>文/前桥和弥 在Donald C. Gause 和Gerald M. Weinberg 合著的《你的灯亮着吗？》一书中，有这样一节。 某计算机制造商开发了一种新型打印机。技术小组在如何保证打印精度的问题上非常苦恼，每次进行新的测试时，工程师都不得不花很长的时间测量打印机的输出结果来追求精确性。 丹（Dan Daring）是这个小组中最年轻但或许是最聪明的工程师。 他发明了一种工具，即每隔8 英寸就在铝条上嵌上小针。使用这个工具，可以很快地找到打印机输出位置的误差。 这个发明显著地提高了生产效率，丹的上司非常高兴，提议给丹颁发一个公司的特别奖赏。他从车间里拿了这个工具，带回办公室，这样他写报告的时候还可以仔细地研究一下。 这个上司显然还用不惯这个工具，当他把这个工具放在桌子上 的时候，将针尖朝上了。更不幸的是，当丹的上司的上司友好地坐 到桌角上，打算谈谈给丹颁发奖励时，部门内的所有人都听到了他 痛苦的尖叫声——他的屁股上被扎了两个相距8 英寸的孔。 C 语言就恰如这个工具。也就是说，它是一门 为了解决眼前问题，由开发现场的人发明的， 虽然使用方便， 但看上去不怎么顺眼， 如果不熟悉的人糊里糊涂地使用了它，难免会带来“悲剧”的语言。 C 的发展历程 众所周知，C 原本是为了开发UNIX 操作系统而设计的语言。 如此说来，好像C 应该比UNIX 更早问世，可惜事实并非如此，最早的 UNIX 是用汇编来写的。因为厌倦了总是苦哈哈地使用汇编语言进行编程，UNIX 的开发者Ken Tompson 开发了一种称为“B”的语言。B 语言是1967 年剑桥大学的Martin Richard 开发的BCPL（Basic CPL）的精简版本。BCPL 的前身是1963 年剑桥大学和伦敦大学共同研究开发的CPL（Combined Programming Lanugage） 语言。 B 语言不直接生成机器码，而是由编译器生成栈式机（Stack Machine）用 的中间代码，中间代码通过解释器（interpreter）执行（类似Java 和早期的 Pascal）。因此，B 语言的执行效率非常低，结果，在后来的UNIX [...]&lt;img src=&quot;http://www1.feedsky.com/t1/723865974/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15528/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>图书推荐</category><category>C++</category><category>语言</category><pubDate>Mon, 11 Mar 2013 17:28:00 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15528/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15528</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15528/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/723865974/6222641</fs:itemid></item><item><title>如何对付团队中的“害群之马”</title><link>http://www.programmer.com.cn/15454/</link><content:encoded>&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;文/Brian W. Fitzpatrick Ben Collins-Sussman&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;软件开发中最难的是跟人打交道，防止那些捣乱的家伙破坏你的团队辛辛苦苦建立起来的合作氛围。更重要的是，我们要探讨一下怎么对付那些已经在团队里的害群之马。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;&lt;img class=&quot;aligncenter  wp-image-15506&quot; title=&quot;封面&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/QQ截图20130308115110.jpg&quot; alt=&quot;&quot; width=&quot;218&quot; height=&quot;325&quot; /&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;strong&gt;&lt;span id=&quot;more-15454&quot;&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是“害群”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们已经讨论了培养稳定的、沟通无碍的团队文化有多重要。我们一直在强调，好的文化氛围应该包括基于共识决策的开发模式、高质量的代码、代码审查，以及能让人放心尝试新事物或者快速失败的环境。&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;同样重要的是还要了解哪些东西不应该包括在文化里面。如果你打算打造一支高效敏捷的团队，那么知道自己不要什么也是非常重要的。虽然优秀的工程师能让团队更快更有效率，但是有些不好的习惯和做事风格会拖累团队，让公司变得不再那么让人舒服—最终这些都会侵蚀队伍的团结。&lt;/p&gt;
&lt;p&gt;我们刚开始在研讨会上说到软件开发中的社交难题的时候，用的演讲标题是“怎么对付坏蛋”，大会主席建议我们把它改成“项目如何才能在害群之马的铁蹄下幸存”，希望这种八卦风格的标题能吸引到更多听众。事实上他是有道理的，这个演讲在很多研讨会上大受欢迎，听众多得连站的地方都没有。吸引听众的不单是“害群”这样非常负面的词汇，还有一个原因就是很多人都有这样不得不和那些叫人恼火的人打交道的经历。演讲到最后几乎肯定会变成一场诉苦大会，听众们会交换自己的故事，商量对策。&lt;/p&gt;
&lt;p&gt;不过这样其实是很危险的。一般来说，一个人总是让自己沉浸在负面情绪里是不健康的行为—长远来讲，它会侵蚀你的一切，制造更多麻烦。“害群之马”是很大的帽子，一下子就把“我们”（也就是好人）和“他们”（捣乱的坏蛋）对立了起来。其实完全可以换一个思路来看这个问题。在带领团队的时候，不要把自己想成是一帮精英，众志成城地要把所有的烂人都轰走，而是要培养一种拒绝容忍负面行为的文化氛围，这才是正确的态度。要剔走的是行为本身，而不是人，单纯地区分好人和坏人是很幼稚的想法。规定好哪些是不可容忍的行为，然后予以惩戒，才是更有建设性的务实态度。&lt;/p&gt;
&lt;p&gt;简单起见，我们暂时继续采用“害群之马”这种修辞手法来指代那种行为不端的人，但是在日常对话里千万不要轻易使用这个词哦！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保护团队&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还记得酵母的比喻吗？团队文化和创始人的气质是紧密联系的。对团队文化影响最深的就是创始人，要是创始团队的文化不够强势，那么后来的文化就会压过它。如果创始团队很清楚哪些行为是可以接受的，哪些行为是不可以接受的，那么这些东西就能传承很多年。&lt;/p&gt;
&lt;p&gt;我们两个在开源项目圈子里混了好多年，多年的经验也充分印证了这一点。&lt;/p&gt;
&lt;p&gt;Subversion&lt;span style=&quot;font-family: 宋体;&quot;&gt;是我们接触最多的项目，刚开始的时候它只有很少的成员。大家都非常谦虚，相互之间有一种自然而然的信任感和尊重。十一年来，项目的参与者来来去去至少三四拨（大部分创始人早就离开了），但是传统还是保留了下来&lt;/span&gt;—大家都和和气气的，很有礼貌，相互尊敬。这不但是因为它坚持了高标准，还因为文化总是会进行自我选择。物以类聚，人以群分。&lt;/p&gt;
&lt;p&gt;自我选择也很容易往坏的方向发展。如果团队一开始就聚集了一帮愤青，那么它就会有越来越多的同类。有些项目我们实在是不愿意提，比如&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Linux&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;内核社区就是典型的例子&lt;/span&gt;—无止境的斗嘴，狂妄的发言，还有各种出口伤人。这样的团队或许能完成很多工作，但是总体上的运营效率却叫人怀疑。要是在人身攻击上没有浪费这么多精力，那么能多做多少事情？如果没有把那些礼貌的人拒之门外，那么他们的潜在贡献有多大？&lt;/p&gt;
&lt;p&gt;我们再次提到这个话题是为了让你明白其中的代价，害群之马会直接危害到你的高效团队。如果容忍了不良行为的存在，不但你的生产力会受到影响，还会渐渐侵蚀团队的文化。而对抗它的最好办法就是通过一系列强有力的最佳实践和流程来提高团队的抵抗力。这些内容在第二章里都已经讲过了，这里再简单回顾一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保护团队，抵御不良行为&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写一份明明白白的任务宗旨。这样可以随时保持专注，知道哪些是目标，哪些不是。&lt;/li&gt;
&lt;li&gt;E-mail&lt;span style=&quot;font-family: 楷体_GB2312;&quot;&gt;讨论要有礼仪。保留归档，要求新人研读，防范那些“嘈杂的少数人”。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;所有历史都要有记录。这不单指代码历史，还有设计决策、重要的&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;bug&lt;/span&gt;&lt;span style=&quot;font-family: 楷体_GB2312;&quot;&gt;修复，以及过去犯下的错误。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;有效地进行协作。利用版本控制，代码改动要尽可能的小，方便进行审查，扩大“公车因子”，避免出现领地感。&lt;/li&gt;
&lt;li&gt;修复&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;bug&lt;/span&gt;&lt;span style=&quot;font-family: 楷体_GB2312;&quot;&gt;，测试，发布软件要有清晰的政策和流程。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;降低新人加入时的壁垒。&lt;/li&gt;
&lt;li&gt;依赖基于共识决策，在无法达成共识的时候也要准备好化解矛盾的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最重要的是，这些最佳实践越根深蒂固，社区就越不能容忍各种有害行为。等捣乱的人真的出现的时候，你也就做好准备了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发现威胁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要帮助团队抵御害群之马，首先要明白的就是到底什么才算是威胁，什么时候要引起注意。&lt;/p&gt;
&lt;p&gt;团队的注意力和专注力是最容易受到威胁的。&lt;/p&gt;
&lt;p&gt;注意力和专注力是最宝贵的资源。团队规模越大，编写软件和解决有趣问题的能力就越强—不过这种能力毕竟是有极限的。要是你不去主动保护它们，很容易就会被害群之马引入歧途。团队最终会争论不休，变得心烦意乱、身心疲惫。所有人都会把注意力和专注力放到那些编写优秀软件以外的事情上去。&lt;/p&gt;
&lt;p&gt;这时你大概会问：害群之马到底是指什么样子的人？正所谓有则改之，无则加勉嘛。&lt;/p&gt;
&lt;p&gt;根据我们的经验，很少会有人故意干坏事（也就是存心捣乱的那种）。我们管这种行为叫作“钓鱼”，通常无视这种人就可以了。而大多数人在行为出格的时候，要么是没有意识到自己过分了，要么就是根本不在乎别人的感受。无知和冷漠其实比蓄意更严重。绝大多数出格的行为都可以归结为缺乏基本的&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;HRT&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里是一些特别值得注意的信号和模式。只要这些东西一冒头，我们就会对这个人亮出黄牌—也就是说，我们会在心里作个记号，记住这个总是做出危害大家行为的家伙，以后和他打交道的时候就会格外小心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你必须保护好团队的注意力和专注力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;不尊重别人的时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总会有一些人搞不清楚项目的状况，他们的危害通常是浪费团队的时间。他们宁可不断地拿那些很容易就能找到答案的问题去骚扰整个团队，也不愿意自己花点时间去读一读最基本的项目文档、任务宗旨、&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;FAQ&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，或是最近的邮件讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们在&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;项目里就曾经碰到过这样一个人，他把开发主论坛当成了自己每天报流水账的地方。查理实际上没有贡献什么代码，但他每隔两三个小时就会发布自己最新的异想天开。这样就无可避免地产生了很多回复，去解释为什么他的想法是不正确的，不可能的，已经在开发中了，之前已经讨论过了，或者是已经有文档记录了等。更糟糕的是，查理甚至开始回答那些临时用户的问题，而且都答错了。这样，我们的核心成员只好不断地去更正他的回复。过了好久我们才反应过来，这位和蔼可亲的热心人其实是好心办坏事，大家被他牵扯了太多的精力。本章稍后我们会讨论遇到这种情况的时候该怎么办。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自负&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里“自负”可能不是最恰当的词，我们想要表达的是那种无法接受多数人决议，无法倾听和尊重其他观点，以及不愿作出妥协的人。这种人常常会重新挑起些早就已经结束（并且保留在邮件存档里）的讨论，仅仅是因为当时她不在场。这种人不肯去读存档，也压根不想去思考，她只会要求为了自己重启争论。她常常会就项目的前途作出极端的评价，声称除非按照她的思路走，否则失败就在眼前。&lt;/p&gt;
&lt;p&gt;Subversion&lt;span style=&quot;font-family: 宋体;&quot;&gt;就有过这么一段经历，当时有一名非常聪明的程序员出现在邮件列表里，声称产品的整体设计存在严重缺陷，而自己已经成竹在胸，有一些大刀阔斧的办法来纠正错误，并且坚持项目应该整个推倒重来。他甚至还毛遂自荐希望能亲自领导重建工作，他宣称要是没有他的领导，项目随时都会有覆巢之险。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;项目的创始人浪费了整个星期的时间，和这个家伙无休止地争论，誓要捍卫自己最初的设计目标。所有的注意力和专注力都涣散了。这个人显然无意作出任何妥协，也不想把自己的想法融入到现在的产品里，而项目（已经在公测阶段，拥有大量用户）也不可能重新来过。所以我们只能选择不再争论，回到自己的步调上来。讽刺的是，多年以后，事实表明他的预言在很多方面都是对的，但这并不妨碍&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的巨大成功&lt;/span&gt;—至少在企业级的软件开发上&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;做得很好。这里关键的地方不在于谁对谁错，而是能否和而不同，以及争论是否有继续的必要。一定要提醒自己注意这些问题，有时候你必须作出决定，舍弃一些东西，继续向前。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过分索求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每当有陌生人跟你要求做什么的时候，一定要提高警惕。这样的人把所有的精力都用来抱怨软件功能不足，却不愿意自己动手作点贡献。&lt;/p&gt;
&lt;p style=&quot;text-align: left;&quot;&gt;有时候等天上掉馅饼的心态会演变成过激行为。在运营&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Google&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的项目托管服务时，我们就遇到过这样的例子，当时有一个项目作者要求我们封掉一个用户，因为他的所作所为实在是太讨厌了。这是一个开源的电视游戏模拟器项目，而这个用户最喜欢的游戏却无法在上面正常运行，于是他在问题跟踪系统里提交了一个口气相当粗鲁的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;bug&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;报告。开发人员礼貌地解释了那个游戏跑不起来的原因，还告诉他相当一段时间里可能都没办法修复那个问题，结果那个人接受不了，每天都来骚扰开发人员。他不断地提交同样的&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;bug&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;报告，里面充斥着各种不满，还在其他&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;bug&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;报告里评论说拒绝修复他的问题的程序员是个“蠢货”。尽管项目人员和&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Google&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;管理员屡次警告，他的用词却反而越来越不堪。不管我们怎么努力去消除他的这种破坏性行为，他就是冥顽不灵，万般无奈之下，我们只好祭出最后一招&lt;/span&gt;—彻底把他封掉了。&lt;img class=&quot;aligncenter  wp-image-15504&quot; title=&quot;表1&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/QQ截图20130308114734.jpg&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;314&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幼稚或是莫名其妙的交流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样的人不会用真名。他们常常会用一些幼稚的昵称，比如“&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SuperCamel&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;”、“&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;jubjub89&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;”，或是“&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;SirHacksalot&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;”之类。更糟糕的是，这样的人往往会在不同的地方用不同的昵称&lt;/span&gt;—E-mail&lt;span style=&quot;font-family: 宋体;&quot;&gt;一个，即时消息里又是另外一个，可能提交代码的时候还有一个。更有甚者，你会看到他们用火星文、黑客语、全部大写，甚至含有大量标点符号的沟通方式！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;偏执妄想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面的例子里我们看到，有时候不切实际要求会直接转变成对项目的恶意。我们无数次看到它彻底演变成偏执。当团队和访客的意见不一时，这种心怀恶意的人就会抛出某种阴谋论。要是太把他当真，去花精力和时间反驳的话就实在是太滑稽了。而且如果你已经建立起一条开放透明的沟通渠道的话（正如我们在第二章里所推崇的），这种指控只会显得更加可笑，因为所有的谈话内容都是有公开记录的。我们的建议是根本就不用去理会这种指控。当这种人真的做到这一步的时候，你说什么都是没用的，既然这样干嘛还费这劲呢？还不如把时间用来写代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完美主义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;乍看之下，完美主义者根本就是无害的。尽管时不时地会有一些奇怪的强迫症类型的行为出现，但是总体上这样的人都是谦虚有礼貌的，而且愿意倾听别人的意见，看起来满是快乐的&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;HRT&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和良好的本意。那么问题出在哪里呢？答案就是太追求完美会变得瞻前顾后、犹豫不决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;就拿我们以前的同事来举例吧。帕特里克是一名非常出色的工程师。他做的设计非常出色，代码和测试的质量也很高，人也非常容易相处。但是每当要设计新软件的时候，他就会无休止地调整、改进自己的设计。他从不满足，好像永远也不会开始写代码一样。尽管他对我们所面临的问题有非常好的见解和洞察力，但是团队里的其他成员最后都被折腾到不行。这样下去就没法工作了，我们几个考虑了很久要怎么办。一方面，对团队来说帕特里克是巨大的财富；另一方面，他也妨碍了团队前进的步伐。每次我们打算开始编写代码的时候，他就会很有礼貌地否定我们的方案，指出其中只在理论上成立的潜在问题，而且都是一时半会不会产生什么影响的问题，不知不觉中他让我们整个陷于瘫痪状态。在下一节里，我们会讨论该如何应对这种情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对抗有害行为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们不鼓励仅仅因为别人有点反社会或是不太礼貌就把他们踢走。我们之前已经提过，拉帮结派地把我们（所谓的好人）和他们（所谓的坏人）对立起来不是什么好主意。注意在之前的例子里，我们关注的不是批判人，而是批判“行为”。恶意的行为是不可容忍的，如果重复警告之下仍然没有改观，那么只有考虑正式拒绝了。&lt;/p&gt;
&lt;p&gt;把精力都放在消除恶意行为上常常足以将一个聪明人（虽然可能不太擅长和人打交道）变成团队里的得力干将。几年前我们手下有一个非常出色的工程师，但是他有一个致命的缺点，就是有时候会惹到团队里的其他人。我们没有直接轰走他，而是把他拉到一边问他有没有意识到自己的言论会让别人对他敬而远之。他表现得很吃惊，完全不能理解为什么自己说的话会造成这种效果，但是答应说会调整自己以适应团队。事实证明效果非常好，随着他的转变，问题也就自然消失了。并不是所有的故事都是悲剧收场的！&lt;/p&gt;
&lt;p&gt;好吧，你已经找到了害群之马，可能现在就有人在干扰或是牵扯团队的精力。怎么才能有效地对付这种情况呢？下面是一些行之有效的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转移完美主义者的注意力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦找到解决问题的办法，哪怕不是最佳方案，但是只要够用，就应该把完美主义者的注意力放到其他问题上去。&lt;/p&gt;
&lt;p&gt;这个办法非常好用，&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;就是这样解决完美主义者的难题的。当时实在是没办法了，我们只好把帕特里克叫到一边，告诉他说：“我们决定以这个设计为起点开始工作，看看效果如何。希望你能帮助我们继续解决在这个过程中出现的各种问题。”出人意料的是，帕特里克对此完全没有异议，转身就继续研究其他难题去了。气氛相当融洽，帕特里克也一直在贡献自己的力量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;俗话说，过犹不及。在打造高效团队的时候，一定要时时警惕不要过于追求完美，否则只会适得其反。&lt;/p&gt;
&lt;p&gt;这种转移注意力的办法用在那些花太多时间抱怨和批评的家伙身上也同样有效。有时候对这种人会忍不住回一句“随时欢迎提交补丁”—开源社区里让人闭嘴的委婉说法，但其实不如引导他去正式参与软件的测试，说不定就能发现一些以前修复过的问题又重新出现。这样，虽然他还在发牢骚，但是会比较有建设性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;别去搭理那些挑衅的家伙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Usenet&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;上流传的一句格言&lt;/span&gt;。这对任何蓄意捣乱的家伙来说是最好的手段—这种人会处心积虑地向你和你的团队挑衅。你回复得越多，他就越来劲，结果你就会浪费越来越多的精力和时间。其实无视就是最好的办法。无论心里有多少警言妙语可以一句话就噎死他，都要克制这种冲动。当他发现没人理他的时候，自然就会意兴阑珊地离开。忍住、不回应往往是需要很大的意志力的。坚持！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;别太感情用事&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人往往会很容易表现出防备的心态，不管别人是不是蓄意挑衅。当你被人骂说设计做得太烂，或是谋划什么阴谋，又或者浪费了太多时间去回答再简单不过的问题的时候，的确是很让人郁闷的。但是别忘了，你的任务是写出漂亮的软件，没有义务讨好所有人，也不需要一再去证明自己存在的价值。你越是情绪化，就越容易浪费宝贵的时间去写一些激昂的回帖，而那些都是不值得你关注的人。应战之前应该谨慎一点，时刻保持冷静，知道哪些人是值得回应的，哪些人是可以无视的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓住重点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续刚才的话题，保持理智的更深一层含义就是要学会抓住重点。一个人在抱怨、发泄情绪的时候，一定要认真听他说。虽然会夹杂一些愤怒和粗俗的话，但是要相信对方本质上是没有恶意的。他说的到底有没有道理呢？我们是不是可以从他的经验里学到什么？他的想法是不是值得回应？很多时候答案都是肯定的—那就是虽然他语言上有点刻薄，但背后其实是有亮点的，所以应该尽量把争执再次引向技术讨论。&lt;/p&gt;
&lt;p&gt;我们团队在这一点上做得非常叫人自豪。只要保持绝对冷静，一切以事实说话，发帖人就自然会随着交谈的深入而显得疯狂可笑。到最后没人会相信他说的话，他脸皮再厚也混不下去了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对付挑衅要不卑不亢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了上面提到的办法（就是保持冷静，摆事实，讲道理），有时候连礼貌也可以拿来当武器吓走敌人！这里是一段&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;在&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IRC&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;频道里的真实记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;哈里：Subversion&lt;span style=&quot;font-family: 宋体;&quot;&gt;太烂了，完全用不了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;萨斯曼：有问题可以问我啊。&lt;/p&gt;
&lt;p&gt;哈里：我想要&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;cvs&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;一下某个人的文件。不对，我要抗议一下。那家伙用的是一种叫&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的东西，他用&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;svn&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，不是&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;cvs&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;萨斯曼：你可以装一个&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;svn&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;客户端，然后检出他的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;哈里：所以我就去下了一份&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;啊……结果你以为它可以像&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;cvs&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;那样&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;configure make make install&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;吗？当然不行。比起&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的人，我怪他比较多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;萨斯曼：（你）没办法 ./configure; make; make install不代表软件有严重&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;bug&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。每天都有无数人从&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;svn&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;源码包编译编译软件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;哈里：我可没说有&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;bug&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;萨斯曼：你觉得我们会发布一个像这样的有严重问题的源码包吗？&lt;/p&gt;
&lt;p&gt;哈里：我只是要骂一下这个垃圾（软件）。居然还要我装&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;expat&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;和&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;libxml&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;。（叹气）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;萨斯曼：这些软件在大多数系统上都是预装的。&lt;/p&gt;
&lt;p&gt;萨斯曼：那个人用的是&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;apache&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;服务器吗？说不定你只要下载一份编译好的版本就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;哈里：我不知道，他就说了&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;svn&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;而已……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;萨斯曼：你用的是什么发行版？&lt;/p&gt;
&lt;p&gt;哈里：FreeBSD&lt;/p&gt;
&lt;p&gt;萨斯曼：其实你直接到&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;ports&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;里去&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;make&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;一份就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;哈里：碰到你我什么脾气都没了……我上来是想要吵架发泄的……你也太和蔼可亲、热心助人了吧。&lt;/p&gt;
&lt;p&gt;萨斯曼：:-)&lt;/p&gt;
&lt;p&gt;哈里：什么时候开始&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;IRC&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;频道变成一个这么和谐的地方了？算了不说了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;哈里退出了频道。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;知道什么时候应该放弃&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候，当无论怎么努力都是徒劳的时候，你就应该果断放弃，继续向前。就算你已经花费了大量的精力去纠正有害行为，也要学着去承认失败。&lt;/p&gt;
&lt;p&gt;让我们回到查理的故事，这位友善的哲学家在&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的邮件列表里发了太多的帖子。我们对所有的讨论做了一个统计，发现他在两个月之内挤进了发帖量的前三名。前两名都是项目的核心，而且他们&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;70%&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的帖子都是在回复查理！尽管查理本身没有恶意，但显然我们的精力和注意力都被吸走了。最后我们只好私底下给他发了一封&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;E-mail&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;，（礼貌地）请求他不要再这样频繁地发帖。这段谈话进行得很艰难，主要是因为他没有意识到自己造成了多大的干扰。可是几个星期之后情况仍然没有改观，我们的一个同事只好给他打电话，好好地和他谈了一次（这样的谈话难度更大），要求他彻底停止发帖。最终他还是接受了，虽然有一点难过和不解，但仍然尊重了团队的意愿。大家都觉得有点内疚，因为他一直都没能理解自己到底做了什么，但是大家也觉得这么做是正确的。要解决好这种事情是很微妙的，我们只有谨守&lt;/span&gt;&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;HRT&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的原则才能处理得当。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注长远&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通向成熟软件产品的道路上有无数的干扰。要是说在对付害群之马所带来的干扰时最常见的情景是什么，那肯定就是太容易被当时的情况所吸引了。如果你发现了所谓的有害行为，一定要问自己两个关键的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然短期之内会损失一些注意力和专注力，长远来讲你真的相信项目会因此受益吗？&lt;/li&gt;
&lt;li&gt;你相信这些冲突最终会以有益的方式解决吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把注意力放在重要的地方，不要被眼前的东西迷惑&lt;/p&gt;
&lt;p&gt;只要任何一个回答是“不”，你就应该果断介入，中止那种行为。虽然人们常常会自我安慰说暂时忍耐一下换取短期利益是值得的，但其实事实并非如此：例如，有人或许在技术上贡献良多，可仍然会做出一些有害团队的行为，这时往往就会为了那点技术上的优势而选择对他睁一只眼闭一只眼。但是这时候千万要三思！&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;HRT&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的氛围是无可替代的，而再强的技术也是可以替代的。我们以前有一位同事这样说道：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;我有不少朋友都认识他。其中有一个是这样说的，“他常常游走在天才和疯子之间。可问题是，现在天才已经不稀奇了，没人会因此接受这样举止古怪的人了”。—格雷格·哈德森&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;这里格雷格说的不是通常意义上的“天才”，他的意思是这个世界上有的是合格的程序员。如果你发现有人在长远来讲会威胁到团队的文化，那么不妨再等另一个出现。&lt;/p&gt;
&lt;p&gt;我们在&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;Subversion&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;项目里就曾经遇到过这样的情况。团队有严格规定，不准把名字写到源文件里（这一条我们在第二章里就讨论过了），我们觉得做只会产生领地感。如果代码里有别人的名字，修改的时候会觉得有点担忧，而且这么做还会人为地降低公车因子。所以在版本控制的记录里认可大家的贡献才是比较恰当的做法，我们在项目的根目录里放了一个这样的文件，里面有所有贡献者的名字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有一天，来了一个非常聪明的程序员，主动写了一个所有人都想要的新特性，工作量还不小。在他提交代码审查的时候，我们只是要求他删掉文件开头的名字—我们会在和别人一样的地方感谢他的贡献。可是他拒绝了，谈判陷入了僵局。最后，大家决定拒绝接受他的代码，他带着自己的玩具离开了。虽然大家都很失望，但是我们不愿意仅仅是为了能快点得到新特性，就打破自己的规矩（进而放弃自己的传统）。几个月之后，就有其他人重新实现了这个特性。&lt;/p&gt;
&lt;p&gt;在这里要再次明确强调：为了短期利益而打破规矩不值得—特别是对于那些不懂得尊重&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;HRT&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;重要性的家伙来说，再大的天才也没用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们讨论了很多场景，说到最后似乎会产生一种偏执的感觉。但是别忘了，这个世界里混蛋其实并不多。正如罗伯特·&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;J&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;·翰龙所说的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不要把用愚蠢可以解释的行为归结为恶意的。&lt;/p&gt;
&lt;p&gt;这里我们更倾向用“无知”而不是“愚蠢”，但是基本思想还是一样的。就像我们在一开始提到的，把人简单地分成好和坏是很幼稚的。没有什么坏人处心积虑地想要毁掉你的文化—大多数人只是被误导了而已；又或者只是想要得到认可，同时又不太擅长与人交际罢了。不管怎么样，你的任务不是要培养傲慢的态度，把那些没有那么聪明的普通人赶出项目；你的任务是拒绝容忍毁灭性的行为，明确自己对&lt;span style=&quot;font-family: Times New Roman;&quot;&gt;HRT&lt;/span&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;的期望。有智慧的人才能体会其中的差别，而有能力的人才能真正予以执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文选自《极客与团队》一书，作者Brian W. Fitzpatrick Ben Collins-Sussman，徐旭铭译，由人民邮电出版社出版发行。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/723865975/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15454/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15454/feed/</wfw:commentRss><slash:comments>0</slash:comments><description>文/Brian W. Fitzpatrick Ben Collins-Sussman 软件开发中最难的是跟人打交道，防止那些捣乱的家伙破坏你的团队辛辛苦苦建立起来的合作氛围。更重要的是，我们要探讨一下怎么对付那些已经在团队里的害群之马。 &amp;#160; 什么是“害群” 我们已经讨论了培养稳定的、沟通无碍的团队文化有多重要。我们一直在强调，好的文化氛围应该包括基于共识决策的开发模式、高质量的代码、代码审查，以及能让人放心尝试新事物或者快速失败的环境。 同样重要的是还要了解哪些东西不应该包括在文化里面。如果你打算打造一支高效敏捷的团队，那么知道自己不要什么也是非常重要的。虽然优秀的工程师能让团队更快更有效率，但是有些不好的习惯和做事风格会拖累团队，让公司变得不再那么让人舒服—最终这些都会侵蚀队伍的团结。 我们刚开始在研讨会上说到软件开发中的社交难题的时候，用的演讲标题是“怎么对付坏蛋”，大会主席建议我们把它改成“项目如何才能在害群之马的铁蹄下幸存”，希望这种八卦风格的标题能吸引到更多听众。事实上他是有道理的，这个演讲在很多研讨会上大受欢迎，听众多得连站的地方都没有。吸引听众的不单是“害群”这样非常负面的词汇，还有一个原因就是很多人都有这样不得不和那些叫人恼火的人打交道的经历。演讲到最后几乎肯定会变成一场诉苦大会，听众们会交换自己的故事，商量对策。 不过这样其实是很危险的。一般来说，一个人总是让自己沉浸在负面情绪里是不健康的行为—长远来讲，它会侵蚀你的一切，制造更多麻烦。“害群之马”是很大的帽子，一下子就把“我们”（也就是好人）和“他们”（捣乱的坏蛋）对立了起来。其实完全可以换一个思路来看这个问题。在带领团队的时候，不要把自己想成是一帮精英，众志成城地要把所有的烂人都轰走，而是要培养一种拒绝容忍负面行为的文化氛围，这才是正确的态度。要剔走的是行为本身，而不是人，单纯地区分好人和坏人是很幼稚的想法。规定好哪些是不可容忍的行为，然后予以惩戒，才是更有建设性的务实态度。 简单起见，我们暂时继续采用“害群之马”这种修辞手法来指代那种行为不端的人，但是在日常对话里千万不要轻易使用这个词哦！ 保护团队 还记得酵母的比喻吗？团队文化和创始人的气质是紧密联系的。对团队文化影响最深的就是创始人，要是创始团队的文化不够强势，那么后来的文化就会压过它。如果创始团队很清楚哪些行为是可以接受的，哪些行为是不可以接受的，那么这些东西就能传承很多年。 我们两个在开源项目圈子里混了好多年，多年的经验也充分印证了这一点。 Subversion是我们接触最多的项目，刚开始的时候它只有很少的成员。大家都非常谦虚，相互之间有一种自然而然的信任感和尊重。十一年来，项目的参与者来来去去至少三四拨（大部分创始人早就离开了），但是传统还是保留了下来—大家都和和气气的，很有礼貌，相互尊敬。这不但是因为它坚持了高标准，还因为文化总是会进行自我选择。物以类聚，人以群分。 自我选择也很容易往坏的方向发展。如果团队一开始就聚集了一帮愤青，那么它就会有越来越多的同类。有些项目我们实在是不愿意提，比如Linux内核社区就是典型的例子—无止境的斗嘴，狂妄的发言，还有各种出口伤人。这样的团队或许能完成很多工作，但是总体上的运营效率却叫人怀疑。要是在人身攻击上没有浪费这么多精力，那么能多做多少事情？如果没有把那些礼貌的人拒之门外，那么他们的潜在贡献有多大？ 我们再次提到这个话题是为了让你明白其中的代价，害群之马会直接危害到你的高效团队。如果容忍了不良行为的存在，不但你的生产力会受到影响，还会渐渐侵蚀团队的文化。而对抗它的最好办法就是通过一系列强有力的最佳实践和流程来提高团队的抵抗力。这些内容在第二章里都已经讲过了，这里再简单回顾一下。 保护团队，抵御不良行为 写一份明明白白的任务宗旨。这样可以随时保持专注，知道哪些是目标，哪些不是。 E-mail讨论要有礼仪。保留归档，要求新人研读，防范那些“嘈杂的少数人”。 所有历史都要有记录。这不单指代码历史，还有设计决策、重要的bug修复，以及过去犯下的错误。 有效地进行协作。利用版本控制，代码改动要尽可能的小，方便进行审查，扩大“公车因子”，避免出现领地感。 修复bug，测试，发布软件要有清晰的政策和流程。 降低新人加入时的壁垒。 依赖基于共识决策，在无法达成共识的时候也要准备好化解矛盾的方法。 最重要的是，这些最佳实践越根深蒂固，社区就越不能容忍各种有害行为。等捣乱的人真的出现的时候，你也就做好准备了。 发现威胁 要帮助团队抵御害群之马，首先要明白的就是到底什么才算是威胁，什么时候要引起注意。 团队的注意力和专注力是最容易受到威胁的。 注意力和专注力是最宝贵的资源。团队规模越大，编写软件和解决有趣问题的能力就越强—不过这种能力毕竟是有极限的。要是你不去主动保护它们，很容易就会被害群之马引入歧途。团队最终会争论不休，变得心烦意乱、身心疲惫。所有人都会把注意力和专注力放到那些编写优秀软件以外的事情上去。 这时你大概会问：害群之马到底是指什么样子的人？正所谓有则改之，无则加勉嘛。 根据我们的经验，很少会有人故意干坏事（也就是存心捣乱的那种）。我们管这种行为叫作“钓鱼”，通常无视这种人就可以了。而大多数人在行为出格的时候，要么是没有意识到自己过分了，要么就是根本不在乎别人的感受。无知和冷漠其实比蓄意更严重。绝大多数出格的行为都可以归结为缺乏基本的HRT。 这里是一些特别值得注意的信号和模式。只要这些东西一冒头，我们就会对这个人亮出黄牌—也就是说，我们会在心里作个记号，记住这个总是做出危害大家行为的家伙，以后和他打交道的时候就会格外小心。 你必须保护好团队的注意力和专注力 不尊重别人的时间 总会有一些人搞不清楚项目的状况，他们的危害通常是浪费团队的时间。他们宁可不断地拿那些很容易就能找到答案的问题去骚扰整个团队，也不愿意自己花点时间去读一读最基本的项目文档、任务宗旨、FAQ，或是最近的邮件讨论。 我们在Subversion项目里就曾经碰到过这样一个人，他把开发主论坛当成了自己每天报流水账的地方。查理实际上没有贡献什么代码，但他每隔两三个小时就会发布自己最新的异想天开。这样就无可避免地产生了很多回复，去解释为什么他的想法是不正确的，不可能的，已经在开发中了，之前已经讨论过了，或者是已经有文档记录了等。更糟糕的是，查理甚至开始回答那些临时用户的问题，而且都答错了。这样，我们的核心成员只好不断地去更正他的回复。过了好久我们才反应过来，这位和蔼可亲的热心人其实是好心办坏事，大家被他牵扯了太多的精力。本章稍后我们会讨论遇到这种情况的时候该怎么办。 自负 这里“自负”可能不是最恰当的词，我们想要表达的是那种无法接受多数人决议，无法倾听和尊重其他观点，以及不愿作出妥协的人。这种人常常会重新挑起些早就已经结束（并且保留在邮件存档里）的讨论，仅仅是因为当时她不在场。这种人不肯去读存档，也压根不想去思考，她只会要求为了自己重启争论。她常常会就项目的前途作出极端的评价，声称除非按照她的思路走，否则失败就在眼前。 Subversion就有过这么一段经历，当时有一名非常聪明的程序员出现在邮件列表里，声称产品的整体设计存在严重缺陷，而自己已经成竹在胸，有一些大刀阔斧的办法来纠正错误，并且坚持项目应该整个推倒重来。他甚至还毛遂自荐希望能亲自领导重建工作，他宣称要是没有他的领导，项目随时都会有覆巢之险。 项目的创始人浪费了整个星期的时间，和这个家伙无休止地争论，誓要捍卫自己最初的设计目标。所有的注意力和专注力都涣散了。这个人显然无意作出任何妥协，也不想把自己的想法融入到现在的产品里，而项目（已经在公测阶段，拥有大量用户）也不可能重新来过。所以我们只能选择不再争论，回到自己的步调上来。讽刺的是，多年以后，事实表明他的预言在很多方面都是对的，但这并不妨碍Subversion的巨大成功—至少在企业级的软件开发上Subversion做得很好。这里关键的地方不在于谁对谁错，而是能否和而不同，以及争论是否有继续的必要。一定要提醒自己注意这些问题，有时候你必须作出决定，舍弃一些东西，继续向前。 过分索求 每当有陌生人跟你要求做什么的时候，一定要提高警惕。这样的人把所有的精力都用来抱怨软件功能不足，却不愿意自己动手作点贡献。 有时候等天上掉馅饼的心态会演变成过激行为。在运营Google的项目托管服务时，我们就遇到过这样的例子，当时有一个项目作者要求我们封掉一个用户，因为他的所作所为实在是太讨厌了。这是一个开源的电视游戏模拟器项目，而这个用户最喜欢的游戏却无法在上面正常运行，于是他在问题跟踪系统里提交了一个口气相当粗鲁的bug报告。开发人员礼貌地解释了那个游戏跑不起来的原因，还告诉他相当一段时间里可能都没办法修复那个问题，结果那个人接受不了，每天都来骚扰开发人员。他不断地提交同样的bug报告，里面充斥着各种不满，还在其他bug报告里评论说拒绝修复他的问题的程序员是个“蠢货”。尽管项目人员和Google管理员屡次警告，他的用词却反而越来越不堪。不管我们怎么努力去消除他的这种破坏性行为，他就是冥顽不灵，万般无奈之下，我们只好祭出最后一招—彻底把他封掉了。 幼稚或是莫名其妙的交流 这样的人不会用真名。他们常常会用一些幼稚的昵称，比如“SuperCamel”、“jubjub89”，或是“SirHacksalot”之类。更糟糕的是，这样的人往往会在不同的地方用不同的昵称—E-mail一个，即时消息里又是另外一个，可能提交代码的时候还有一个。更有甚者，你会看到他们用火星文、黑客语、全部大写，甚至含有大量标点符号的沟通方式！ 偏执妄想 在上面的例子里我们看到，有时候不切实际要求会直接转变成对项目的恶意。我们无数次看到它彻底演变成偏执。当团队和访客的意见不一时，这种心怀恶意的人就会抛出某种阴谋论。要是太把他当真，去花精力和时间反驳的话就实在是太滑稽了。而且如果你已经建立起一条开放透明的沟通渠道的话（正如我们在第二章里所推崇的），这种指控只会显得更加可笑，因为所有的谈话内容都是有公开记录的。我们的建议是根本就不用去理会这种指控。当这种人真的做到这一步的时候，你说什么都是没用的，既然这样干嘛还费这劲呢？还不如把时间用来写代码。 完美主义 乍看之下，完美主义者根本就是无害的。尽管时不时地会有一些奇怪的强迫症类型的行为出现，但是总体上这样的人都是谦虚有礼貌的，而且愿意倾听别人的意见，看起来满是快乐的HRT和良好的本意。那么问题出在哪里呢？答案就是太追求完美会变得瞻前顾后、犹豫不决。 就拿我们以前的同事来举例吧。帕特里克是一名非常出色的工程师。他做的设计非常出色，代码和测试的质量也很高，人也非常容易相处。但是每当要设计新软件的时候，他就会无休止地调整、改进自己的设计。他从不满足，好像永远也不会开始写代码一样。尽管他对我们所面临的问题有非常好的见解和洞察力，但是团队里的其他成员最后都被折腾到不行。这样下去就没法工作了，我们几个考虑了很久要怎么办。一方面，对团队来说帕特里克是巨大的财富；另一方面，他也妨碍了团队前进的步伐。每次我们打算开始编写代码的时候，他就会很有礼貌地否定我们的方案，指出其中只在理论上成立的潜在问题，而且都是一时半会不会产生什么影响的问题，不知不觉中他让我们整个陷于瘫痪状态。在下一节里，我们会讨论该如何应对这种情况。 对抗有害行为 我们不鼓励仅仅因为别人有点反社会或是不太礼貌就把他们踢走。我们之前已经提过，拉帮结派地把我们（所谓的好人）和他们（所谓的坏人）对立起来不是什么好主意。注意在之前的例子里，我们关注的不是批判人，而是批判“行为”。恶意的行为是不可容忍的，如果重复警告之下仍然没有改观，那么只有考虑正式拒绝了。 [...]&lt;img src=&quot;http://www1.feedsky.com/t1/723865975/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15454/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>图书推荐</category><category>团队</category><category>管理</category><pubDate>Fri, 08 Mar 2013 13:11:30 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15454/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15454</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15454/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/723865975/6222641</fs:itemid></item><item><title>Eucalyptus首席财务官王宁：有理想，就去追</title><link>http://www.programmer.com.cn/15375/</link><content:encoded>&lt;p&gt;1984年从北大物理系毕业后，我通过CUSPEA项目（杨振宁和李政道发起的物理学研究生交换项目）到了美国，先在加州大学伯克利分校读了博士，然后又分别在法国和加州理工学院做了博士后。&lt;/p&gt;
&lt;div id=&quot;attachment_15492&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 305px&quot;&gt;&lt;img class=&quot;size-full wp-image-15492&quot; title=&quot;Eucalyptus首席财务官王宁&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/QQ截图20130307224852-.jpg&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;444&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;Eucalyptus首席财务官王宁&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;&lt;span id=&quot;more-15375&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;博士后出站后，我没有选择继续做物理研究，而是转战商业界，加入麦肯锡。因为在我看来，物理学是一个非常好的培养思维能力和解决问题能力的专业，所以在我以后所从事的技术、运营、财务等风格迥异的工作时，物理基础都给了我很多帮助。&lt;/p&gt;
&lt;p&gt;我在麦肯锡工作了将近四年，主要做汽车、制药、音乐、计算机销售等行业，包括战略、运营、兼并和收购、预算等工作，学到了很多不同工业界和行业的东西。&lt;/p&gt;
&lt;p&gt;1999年，适逢互联网热潮，我凭着自己的判断，果断离开麦肯锡，加入一家卖汽车零件的电商CarPart。刚开始，我是做战略方面的工作，但由于网站存在些问题，我便帮着想办法、出主意。可能是学理工科的原因，我的很多建议被采纳，渐渐和网站开发人员、数据库设计人员和UI设计师的合作越来越多、越走越近，以致于后来成了公司的CTO。本来以为离开物理研究后，今生就肯定与技术无缘了，没想到因为这份渊源，让我在IT业待了这么多年，并且还会继续待下去。&lt;/p&gt;
&lt;p&gt;后来我又陆续在几家不同的电商创业公司担任COO、CFO、CTO方面的工作。比如在2008年，我加入了lynda.com，先是担任CFO和CTO，负责招聘和组建研发团队，花9个月时间将整个网站重写。后来又当COO，三年多后，销售和利润率都长了三到四倍。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #800080;&quot;&gt;&lt;strong&gt;跟对人，选对公司，看好方向&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2012年，我加入了Eucalyptus公司，担任CFO。很多人问我，为何离开耕耘了13年的电商行业，而加入一家自己之前完全不熟悉的企业软件公司。我都会和他们解释这些年来积累的对机会选择的标准。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一，团队和团队领导是否值得我跟。我们CEO Marten Mickos曾是MySQL CEO，我能从他那里学到好多如何做好领导的知识。&lt;/li&gt;
&lt;li&gt;第二，公司的发展前景如何，我加入了之后是否能帮助公司做得更好，是否能让我有新的空间学新的东西。Eucalyptus给了我第一次用中文与中国同事合作的机会。&lt;/li&gt;
&lt;li&gt;第三，整个行业是否有前途。云计算有大好发展前景。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是基于这三个方面的考虑，我加入了Eucalyptus。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #800080;&quot;&gt;做重要而非紧急的事情&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你有没有过这样的经历：事情总是没完没了，也有数不清的会要开，你疲于奔命？每天工作时间很长，甚至周末都要加班，却希望把每件事情做好？&lt;/p&gt;
&lt;p&gt;诚然，这种希望是好的，但希望终归是希望，基本不太可能把每件事情都做得漂亮，因为人总是没有足够的时间、精力和资源去处理好每件事情。因此，我们任何人做任何事情，都要区分好轻重缓急。要抽时间做重要而不紧急的的事情。如果一个领导不花时间去做重要的事情，公司很难成功。把握时间要像二八法则那样，花费20%的精力和时间，达到80%的结果。&lt;/p&gt;
&lt;p&gt;我们要给自己养成一种优先做重要事情的习惯。比如，我每周都会抽出半天时间，去一个与工作环境截然不同的地方，抛开每天烦琐的事情，去思考现在有哪些重要的事情，还没有考虑到、没有去安排、还没有去做，这样可以让我把自己的思考放到更高的一个程度。在这里，我推荐大家阅读《The 7 Habits of Highly Effective People》这本书，你会从中学到很多。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #800080;&quot;&gt;&lt;strong&gt;大胆去追求理想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;人最重要的是要知道喜欢做什么、为什么喜欢、自己的强项在哪里，在这种情况下，如果能去做想做的事情，那么事业发展就会比较容易和开心。比如我当初决定放弃学了多年的物理时，也是很不舍，但我发现我骨子里还是想做一些实际的事情。所以我努力在麦肯锡学习企业管理方法，在后来这么多家公司学习怎样管理公司、领导团队、设计产品、构建网站。这个过程中，我的兴趣并不是做到什么职位、有多大的团队、多大的权利，而是能否帮助把公司做得更好、能否做出让用户认为好的产品。&lt;/p&gt;
&lt;p&gt;人生就是一个旅程，对我来说，最重要的是在旅程中找到一帮志同道合的朋友一起做自己想做的事情，不要那么世故和勾心斗角，因为虽说做有些事情可能在短期内能得到不错的利益或者好处，但扪心自问，人生这样值得吗？&lt;/p&gt;
&lt;p&gt;在这个节日里，我想跟中国女IT人说，有理想，就尽管去追求，不要有包袱。哪怕失败也可以爬起来继续前行，何况失败未必是坏事。节日快乐，愿我们都有勇气去追求理想！&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;&lt;strong&gt;&lt;br /&gt;
&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #800080;&quot;&gt;&lt;strong&gt;妇女节专题更多文章&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #808080;&quot;&gt;SAP全球企业官、全球执行副总裁兼SAP中国研究院总裁孙小群：&lt;a href=&quot;http://www.programmer.com.cn/15373/&quot; target=&quot;_blank&quot;&gt;掌握自己的命运，让生活充满阳光&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;Twitter高级工程师岳峣：&lt;a href=&quot;http://www.programmer.com.cn/15377/&quot; target=&quot;_blank&quot;&gt;做好自己喜欢的事&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.programmer.com.cn/15074/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;本文选自《程序员》杂志2013年3期，未经允许不得转载。如需转载请联系 market@csdn.net&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dingyue.programmer.com.cn/&quot; target=&quot;_blank&quot;&gt;《程序员》2013年杂志订阅送好礼活动火热进行中&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/723865976/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15375/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15375/feed/</wfw:commentRss><slash:comments>2</slash:comments><description>1984年从北大物理系毕业后，我通过CUSPEA项目（杨振宁和李政道发起的物理学研究生交换项目）到了美国，先在加州大学伯克利分校读了博士，然后又分别在法国和加州理工学院做了博士后。 博士后出站后，我没有选择继续做物理研究，而是转战商业界，加入麦肯锡。因为在我看来，物理学是一个非常好的培养思维能力和解决问题能力的专业，所以在我以后所从事的技术、运营、财务等风格迥异的工作时，物理基础都给了我很多帮助。 我在麦肯锡工作了将近四年，主要做汽车、制药、音乐、计算机销售等行业，包括战略、运营、兼并和收购、预算等工作，学到了很多不同工业界和行业的东西。 1999年，适逢互联网热潮，我凭着自己的判断，果断离开麦肯锡，加入一家卖汽车零件的电商CarPart。刚开始，我是做战略方面的工作，但由于网站存在些问题，我便帮着想办法、出主意。可能是学理工科的原因，我的很多建议被采纳，渐渐和网站开发人员、数据库设计人员和UI设计师的合作越来越多、越走越近，以致于后来成了公司的CTO。本来以为离开物理研究后，今生就肯定与技术无缘了，没想到因为这份渊源，让我在IT业待了这么多年，并且还会继续待下去。 后来我又陆续在几家不同的电商创业公司担任COO、CFO、CTO方面的工作。比如在2008年，我加入了lynda.com，先是担任CFO和CTO，负责招聘和组建研发团队，花9个月时间将整个网站重写。后来又当COO，三年多后，销售和利润率都长了三到四倍。 跟对人，选对公司，看好方向 2012年，我加入了Eucalyptus公司，担任CFO。很多人问我，为何离开耕耘了13年的电商行业，而加入一家自己之前完全不熟悉的企业软件公司。我都会和他们解释这些年来积累的对机会选择的标准。 第一，团队和团队领导是否值得我跟。我们CEO Marten Mickos曾是MySQL CEO，我能从他那里学到好多如何做好领导的知识。 第二，公司的发展前景如何，我加入了之后是否能帮助公司做得更好，是否能让我有新的空间学新的东西。Eucalyptus给了我第一次用中文与中国同事合作的机会。 第三，整个行业是否有前途。云计算有大好发展前景。 正是基于这三个方面的考虑，我加入了Eucalyptus。 做重要而非紧急的事情 你有没有过这样的经历：事情总是没完没了，也有数不清的会要开，你疲于奔命？每天工作时间很长，甚至周末都要加班，却希望把每件事情做好？ 诚然，这种希望是好的，但希望终归是希望，基本不太可能把每件事情都做得漂亮，因为人总是没有足够的时间、精力和资源去处理好每件事情。因此，我们任何人做任何事情，都要区分好轻重缓急。要抽时间做重要而不紧急的的事情。如果一个领导不花时间去做重要的事情，公司很难成功。把握时间要像二八法则那样，花费20%的精力和时间，达到80%的结果。 我们要给自己养成一种优先做重要事情的习惯。比如，我每周都会抽出半天时间，去一个与工作环境截然不同的地方，抛开每天烦琐的事情，去思考现在有哪些重要的事情，还没有考虑到、没有去安排、还没有去做，这样可以让我把自己的思考放到更高的一个程度。在这里，我推荐大家阅读《The 7 Habits of Highly Effective People》这本书，你会从中学到很多。 大胆去追求理想 人最重要的是要知道喜欢做什么、为什么喜欢、自己的强项在哪里，在这种情况下，如果能去做想做的事情，那么事业发展就会比较容易和开心。比如我当初决定放弃学了多年的物理时，也是很不舍，但我发现我骨子里还是想做一些实际的事情。所以我努力在麦肯锡学习企业管理方法，在后来这么多家公司学习怎样管理公司、领导团队、设计产品、构建网站。这个过程中，我的兴趣并不是做到什么职位、有多大的团队、多大的权利，而是能否帮助把公司做得更好、能否做出让用户认为好的产品。 人生就是一个旅程，对我来说，最重要的是在旅程中找到一帮志同道合的朋友一起做自己想做的事情，不要那么世故和勾心斗角，因为虽说做有些事情可能在短期内能得到不错的利益或者好处，但扪心自问，人生这样值得吗？ 在这个节日里，我想跟中国女IT人说，有理想，就尽管去追求，不要有包袱。哪怕失败也可以爬起来继续前行，何况失败未必是坏事。节日快乐，愿我们都有勇气去追求理想！ &amp;#160; 妇女节专题更多文章 SAP全球企业官、全球执行副总裁兼SAP中国研究院总裁孙小群：掌握自己的命运，让生活充满阳光 Twitter高级工程师岳峣：做好自己喜欢的事 &amp;#160; &amp;#160; 本文选自《程序员》杂志2013年3期，未经允许不得转载。如需转载请联系 market@csdn.net 《程序员》2013年杂志订阅送好礼活动火热进行中&lt;img src=&quot;http://www1.feedsky.com/t1/723865976/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15375/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>女人</category><category>每日关注</category><category>妇女节</category><category>热点报道</category><pubDate>Thu, 07 Mar 2013 17:19:36 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15375/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15375</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15375/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/723865976/6222641</fs:itemid></item><item><title>SAP全球企业官孙小群：掌握自己的命运，让生活充满阳光</title><link>http://www.programmer.com.cn/15373/</link><content:encoded>&lt;p&gt;最早接触计算机是在高中，那时发现通过一个小小的Basic就能做出各种各样的程序，这对年少的我来说很是震撼和触动。慢慢地，我萌生了将来要从事计算机工作的想法。随后，我如愿以偿地考入清华大学计算机系，并在之后到德国卡尔斯鲁厄大学继续深造。1997年硕士毕业后，我进入SAP从事石化解决方案的开发工作。&lt;strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div id=&quot;attachment_15466&quot; class=&quot;wp-caption aligncenter&quot; style=&quot;width: 360px&quot;&gt;&lt;img class=&quot;size-full wp-image-15466 &quot; title=&quot;SAP全球企业官孙小群&quot; src=&quot;http://www.programmer.com.cn/wp-content/uploads/2013/03/SAP-8_副本.jpg&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;450&quot; /&gt;&lt;p class=&quot;wp-caption-text&quot;&gt;SAP全球企业官孙小群&lt;/p&gt;&lt;/div&gt;
&lt;p&gt;&lt;span id=&quot;more-15373&quot;&gt;&lt;/span&gt;那时，开发人员会直接跟客户接触，了解客户需求，然后做开发；同时要培训顾问、项目执行人员和客户，帮助客户上线和提供技术支持。因此会经历整条价值链，这对技术出身的我来说，看到自己做出来的产品一步步得到使用，并能为客户业务带来实质性的变化，深感欣慰。&lt;/p&gt;
&lt;p&gt;接下来的几年，我还做过架构师和项目经理。而做开发时间长了，自然而然地对管理方面的需求越来越多，于是，我从2003年开始边工作边攻读美国西佛罗里达大学的EMBA，逐渐转型为管理者，先后在德国、中国、印度和美国等地带领各支团队开疆拓土。&lt;/p&gt;
&lt;p&gt;与开发人员不同，管理者更多的是需要具备与人沟通这方面的软技能，要学会带领和不断激励团队不畏艰险，为了一个共同的目标齐心协力。为了让自己具备更扎实的软技能，我一方面在工作中注意积累；另一方经历了多种管理训练，甚至还拿到了职业导师的资格。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #800080;&quot;&gt;&lt;strong&gt;只要平衡好，生活和工作两不误&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很多女性到了一定年龄以后，会觉得在家庭和事业两者中只能选其一，有些人甚至会放弃大好前途，把家庭放在第一位。而实际上，在我看来，只要平衡得当，家庭和事业是可以兼顾的。&lt;/p&gt;
&lt;p&gt;我读EMBA时，孩子尚小，丈夫经常出差，而我也要工作和学习，时间可谓相当紧凑。而正是在这种环境下，我学会了怎样最有效地安排和利用自己的时间，并为我将来的管理之路打下了坚实的基础。比如，公司五点钟有会议，而五点钟还要去接孩子，就需要判定对自己来说哪件事情更重要。如果去接孩子，就要提前通知同事，以将对同事和工作的影响降到最小，事后再向其了解会议内容。如果参加会议，就要想好怎样安排孩子。因此，要根据每个场景的优先级做出决定，并且能预见这个决定的结果是什么，看这个结果是否能承受和可管理。&lt;/p&gt;
&lt;p&gt;此外，与家人在一起的时间不在于长短，而要看是否有“质量”：是全身心地与孩子相处半小时，还是边打电话边与他们待在一起俩小时？显然，孩子更喜欢前者，因为那时他们是全部的焦点。这个场景可以推广到工作上——没必要干坐在那儿几个小时，要有“质量”地工作。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #800080;&quot;&gt;&lt;strong&gt;我的职业观&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一份工作做时间长了难免心生厌倦，这时就会考虑做些调整。介于不同的企业文化，有些人会选择换公司，而我则建议优先考虑内部调岗，比如我做过开发、售前、售后、运营以及全球团队的管理。如果这些都满足不了你的话，再考虑换公司。&lt;/p&gt;
&lt;p&gt;另外，建议大家既要懂专业，又要懂管理，要培养自己的“T”型领导力，从深度和广度双方面努力，这是所有走上高管位置的人具备的共同特点。仅有专业知识不能让你有很大发展，必须学会怎样跟同事和客户打交道、怎样管理项目和团队。&lt;/p&gt;
&lt;p&gt;最后，和大家分享我很欣赏的两句格言。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;在海上驾驶帆船时，不要抱怨风吹的方向不对，而是要看怎样控制好帆的方向（Don&amp;#8217;t ask for a more favorable wind, ask for the wisdom to set a better sail）Jim Rohn&lt;/p&gt;
&lt;p&gt;预测未来的最好的办法就是创造未来（The best way to predict the future is to invent it.）Alan Kay&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;希望所有女同胞们都不要抱怨和依靠外部环境，而是要靠自己的能力，来把握自己的命运，让生活充满阳光。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #888888;&quot;&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;孙小群，SAP全球企业官、全球执行副总裁兼SAP中国研究院总裁。&lt;/strong&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #800080;&quot;&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;“妇女节”专题更多文章&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #888888;&quot;&gt;王宁，Eucalyptus首席财务官：&lt;a href=&quot;http://www.programmer.com.cn/15375/&quot; target=&quot;_blank&quot;&gt;有理想，就去追&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;color: #808080;&quot;&gt;&lt;strong&gt;Twitter高级工程师岳峣：&lt;a href=&quot;http://www.programmer.com.cn/15377/&quot; target=&quot;_blank&quot;&gt;做好自己喜欢的事&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.programmer.com.cn/15074/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;本文选自《程序员》杂志2013年3期，未经允许不得转载。如需转载请联系 market@csdn.net&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://dingyue.programmer.com.cn/&quot; target=&quot;_blank&quot;&gt;《程序员》2013年杂志订阅送好礼活动火热进行中&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;img src=&quot;http://www1.feedsky.com/t1/723865977/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15373/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</content:encoded><wfw:commentRss>http://www.programmer.com.cn/15373/feed/</wfw:commentRss><slash:comments>2</slash:comments><description>最早接触计算机是在高中，那时发现通过一个小小的Basic就能做出各种各样的程序，这对年少的我来说很是震撼和触动。慢慢地，我萌生了将来要从事计算机工作的想法。随后，我如愿以偿地考入清华大学计算机系，并在之后到德国卡尔斯鲁厄大学继续深造。1997年硕士毕业后，我进入SAP从事石化解决方案的开发工作。 那时，开发人员会直接跟客户接触，了解客户需求，然后做开发；同时要培训顾问、项目执行人员和客户，帮助客户上线和提供技术支持。因此会经历整条价值链，这对技术出身的我来说，看到自己做出来的产品一步步得到使用，并能为客户业务带来实质性的变化，深感欣慰。 接下来的几年，我还做过架构师和项目经理。而做开发时间长了，自然而然地对管理方面的需求越来越多，于是，我从2003年开始边工作边攻读美国西佛罗里达大学的EMBA，逐渐转型为管理者，先后在德国、中国、印度和美国等地带领各支团队开疆拓土。 与开发人员不同，管理者更多的是需要具备与人沟通这方面的软技能，要学会带领和不断激励团队不畏艰险，为了一个共同的目标齐心协力。为了让自己具备更扎实的软技能，我一方面在工作中注意积累；另一方经历了多种管理训练，甚至还拿到了职业导师的资格。 只要平衡好，生活和工作两不误 很多女性到了一定年龄以后，会觉得在家庭和事业两者中只能选其一，有些人甚至会放弃大好前途，把家庭放在第一位。而实际上，在我看来，只要平衡得当，家庭和事业是可以兼顾的。 我读EMBA时，孩子尚小，丈夫经常出差，而我也要工作和学习，时间可谓相当紧凑。而正是在这种环境下，我学会了怎样最有效地安排和利用自己的时间，并为我将来的管理之路打下了坚实的基础。比如，公司五点钟有会议，而五点钟还要去接孩子，就需要判定对自己来说哪件事情更重要。如果去接孩子，就要提前通知同事，以将对同事和工作的影响降到最小，事后再向其了解会议内容。如果参加会议，就要想好怎样安排孩子。因此，要根据每个场景的优先级做出决定，并且能预见这个决定的结果是什么，看这个结果是否能承受和可管理。 此外，与家人在一起的时间不在于长短，而要看是否有“质量”：是全身心地与孩子相处半小时，还是边打电话边与他们待在一起俩小时？显然，孩子更喜欢前者，因为那时他们是全部的焦点。这个场景可以推广到工作上——没必要干坐在那儿几个小时，要有“质量”地工作。 我的职业观 一份工作做时间长了难免心生厌倦，这时就会考虑做些调整。介于不同的企业文化，有些人会选择换公司，而我则建议优先考虑内部调岗，比如我做过开发、售前、售后、运营以及全球团队的管理。如果这些都满足不了你的话，再考虑换公司。 另外，建议大家既要懂专业，又要懂管理，要培养自己的“T”型领导力，从深度和广度双方面努力，这是所有走上高管位置的人具备的共同特点。仅有专业知识不能让你有很大发展，必须学会怎样跟同事和客户打交道、怎样管理项目和团队。 最后，和大家分享我很欣赏的两句格言。 在海上驾驶帆船时，不要抱怨风吹的方向不对，而是要看怎样控制好帆的方向（Don&amp;#8217;t ask for a more favorable wind, ask for the wisdom to set a better sail）Jim Rohn 预测未来的最好的办法就是创造未来（The best way to predict the future is to invent it.）Alan Kay 希望所有女同胞们都不要抱怨和依靠外部环境，而是要靠自己的能力，来把握自己的命运，让生活充满阳光。 孙小群，SAP全球企业官、全球执行副总裁兼SAP中国研究院总裁。 &amp;#160; “妇女节”专题更多文章 王宁，Eucalyptus首席财务官：有理想，就去追 Twitter高级工程师岳峣：做好自己喜欢的事 &amp;#160; 本文选自《程序员》杂志2013年3期，未经允许不得转载。如需转载请联系 market@csdn.net 《程序员》2013年杂志订阅送好礼活动火热进行中&lt;img src=&quot;http://www1.feedsky.com/t1/723865977/programmer/feedsky/s.gif?r=http://www.programmer.com.cn/15373/&quot; border=&quot;0&quot; height=&quot;0&quot; width=&quot;0&quot; style=&quot;position:absolute&quot; /&gt;</description><category>女人</category><category>每日关注</category><category>妇女节</category><category>热点报道</category><pubDate>Thu, 07 Mar 2013 17:18:39 +0800</pubDate><author>baiyuzhong</author><comments>http://www.programmer.com.cn/15373/#comments</comments><guid isPermaLink="false">http://www.programmer.com.cn/?p=15373</guid><dc:creator>baiyuzhong</dc:creator><fs:srclink>http://www.programmer.com.cn/15373/</fs:srclink><fs:srcfeed>http://www.programmer.com.cn/feed/</fs:srcfeed><fs:itemid>feedsky/programmer/~7674916/723865977/6222641</fs:itemid></item></channel></rss>